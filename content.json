{"meta":{"title":"Matchless’blog","subtitle":null,"description":"登高者必自卑，行远者必自迩，在这个世界上，重要的不是你正站在哪里，而是你正朝什么方向移动！","author":"Matchless","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-06-18T04:29:51.000Z","updated":"2017-06-18T04:29:51.488Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"commonweal","date":"2017-06-18T04:32:32.000Z","updated":"2017-06-18T04:32:32.379Z","comments":true,"path":"commonweal/index.html","permalink":"http://yoursite.com/commonweal/index.html","excerpt":"","text":""},{"title":"about","date":"2017-06-18T04:31:52.000Z","updated":"2017-06-18T04:31:52.699Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2017-06-18T04:32:08.000Z","updated":"2017-06-18T04:32:08.719Z","comments":true,"path":"sitemap/index.html","permalink":"http://yoursite.com/sitemap/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-18T04:26:58.000Z","updated":"2017-06-18T04:26:58.905Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Javascript闭包","slug":"2017-06-21-Javascript闭包","date":"2017-06-20T16:00:00.000Z","updated":"2017-06-21T16:21:17.834Z","comments":true,"path":"2017/06/21/2017-06-21-Javascript闭包/","link":"","permalink":"http://yoursite.com/2017/06/21/2017-06-21-Javascript闭包/","excerpt":"","text":"当function里嵌套function时，内部的function可以访问外部function里的变量。、 function foo(x) { var tmp = 3; function bar(y) { alert(x + y + (++tmp)); } bar(10); } foo(2) 不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。 但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。 function foo(x) { var tmp = 3; return function (y) { alert(x + y + (++tmp)); } } var bar = foo(2); // bar 现在是一个闭包 bar(10); 上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。 但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1. （考虑到六岁这个限制：我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。） 注：现在来整点儿七岁的内容。 上面的x是一个字面值（值传递），和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。 那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！ function foo(x) { var tmp = 3; return function (y) { alert(x + y + tmp); x.memb = x.memb ? x.memb + 1 : 1; alert(x.memb); } } var age = new Number(2); var bar = foo(age); // bar 现在是一个引用了age的闭包 bar(10); 不出我们意料，每次运行bar(10)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量——age，运行两次bar(10)后，age.memb会变成2. 这和HTML对象的内存泄漏有关，呃，不过貌似超出了答题的范围。 JohnMerlino 对Ali说： 这里有一个不用return关键字的闭包例子： function closureExample(objID, text, timedelay) { setTimeout(function() { document.getElementById(objID).innerHTML = text; }, timedelay); } closureExample(‘myDiv’, ‘Closure is created’, 500); JS里的function能访问它们的： 1. 参数 2. 局部变量或函数 3. 外部变量（环境变量？），包括3.1 全局变量，包括DOM。3.2 外部函数的变量或函数。 如果一个函数访问了它的外部变量，那么它就是一个闭包。 注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。 一个典型的例子就是全局变量的使用。 mykhal这样回答： Wikipedia对闭包的定义是这样的：In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function. 从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。 Since scope-defining construction in Javascript is a function, not a code block like in many other languages, what we usually mean by closure in Javascript is a fuction working with nonlocal variables defined in already executed surrounding function. 闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。 var db = (function() { // 创建一个隐藏的object, 这个object持有一些数据 // 从外部是不能访问这个object的 var data = {}; // 创建一个函数, 这个函数提供一些访问data的数据的方法 return function(key, val) { if (val === undefined) { return data[key] } // get else { return data[key] = val } // set } // 我们可以调用这个匿名方法 // 返回这个内部函数，它是一个闭包 })(); db(&apos;x&apos;); // 返回 undefined db(&apos;x&apos;, 1); // 设置data[&apos;x&apos;]为1 db(&apos;x&apos;); // 返回 1 // 我们不可能访问data这个object本身// 但是我们可以设置它的成员 看了这么多外国大牛的解答，不知道你懂还是不懂，反正我是懂了。 P.S. 发布文章之后看到@xiaotie的一篇文章，觉得有必要推荐一下，因为其剖析得更为深入。有人说应该在文章结尾对闭包进行总结，可惜小弟才疏学浅，不能给出一个精辟的总结。 @xiaotie对闭包的总结如下：（1）闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；（2）网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；（3）尽量少学习。","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"2015-12-31杭州西湖文化广场灯光SHOW","slug":"2015-12-30-西湖文化广场灯光SHOW","date":"2015-12-31T14:13:46.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/31/2015-12-30-西湖文化广场灯光SHOW/","link":"","permalink":"http://yoursite.com/2015/12/31/2015-12-30-西湖文化广场灯光SHOW/","excerpt":"作者：无双 地点：杭州西湖文化广场 时间：2015-12-31 工具：手机拍摄","text":"作者：无双 地点：杭州西湖文化广场 时间：2015-12-31 工具：手机拍摄","categories":[{"name":"视频","slug":"视频","permalink":"http://yoursite.com/categories/视频/"}],"tags":[{"name":"拍摄","slug":"拍摄","permalink":"http://yoursite.com/tags/拍摄/"}],"keywords":[{"name":"视频","slug":"视频","permalink":"http://yoursite.com/categories/视频/"}]},{"title":"锤子root","slug":"2015-12-30-锤子root","date":"2015-12-30T10:52:14.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/30/2015-12-30-锤子root/","link":"","permalink":"http://yoursite.com/2015/12/30/2015-12-30-锤子root/","excerpt":"锤子root教程工具：kingroot 地址：http://kingroot.en.uptodown.com/android/download","text":"锤子root教程工具：kingroot 地址：http://kingroot.en.uptodown.com/android/download","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"锤子","slug":"锤子","permalink":"http://yoursite.com/tags/锤子/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"教程","slug":"2015-10-19-教程网址记录","date":"2015-12-27T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/28/2015-10-19-教程网址记录/","link":"","permalink":"http://yoursite.com/2015/12/28/2015-10-19-教程网址记录/","excerpt":"一些教程网址收录，方便学习、查阅。","text":"一些教程网址收录，方便学习、查阅。 css3在线学习：http://isux.tencent.com/css3/index.html?matrix http://selectivizr.com/ 前端资料搜集 ECMAScript 6入门-阮一峰： http://es6.ruanyifeng.com/ JavaScript 标准参考教程 （alpha）-阮一峰：http://javascript.ruanyifeng.com/ 阮一峰的个人网站： http://www.ruanyifeng.com/home.html 阮一峰的博客： http://www.ruanyifeng.com/blog/ GitBook 简明教程: http://www.chengweiyang.cn/gitbook/basic-usage/README.html 汤姆大叔的博客: http://www.cnblogs.com/TomXu/ 大前端 http://www.daqianduan.com/ W3C http://www.w3cplus.com/ 张鑫旭-鑫空间-鑫生活： http://www.zhangxinxu.com/ 腾讯全端 AlloyTeam 团队 Blog: http://www.alloyteam.com/mobiledevelop/ 前段观察： http://www.qianduan.net/ CSS森林： http://www.cssforest.org/blog/ be for web: http://beforweb.com/ 设计达人： http://www.shejidaren.com/ 前端技术社区: http://f2e.im/ 粉丝日志： http://blog.fens.me/","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"markdown使用相关教程","slug":"2015-12-28-markdown","date":"2015-12-27T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/28/2015-12-28-markdown/","link":"","permalink":"http://yoursite.com/2015/12/28/2015-12-28-markdown/","excerpt":"markdown的使用教程工具： marked.js highlight.js 参考链接：https://segmentfault.com/q/1010000002406964 参考链接：https://www.zybuluo.com/mdeditor","text":"markdown的使用教程工具： marked.js highlight.js 参考链接：https://segmentfault.com/q/1010000002406964 参考链接：https://www.zybuluo.com/mdeditor","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"面向对象之属性继承、方法继承","slug":"2015-12-25-面向对象","date":"2015-12-24T16:00:00.000Z","updated":"2017-06-18T04:11:47.252Z","comments":true,"path":"2015/12/25/2015-12-25-面向对象/","link":"","permalink":"http://yoursite.com/2015/12/25/2015-12-25-面向对象/","excerpt":"","text":"使用了对比方法。有函数式写法，然后改成面向对象写法。并且有属性的继承演示、方法继承的演示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!-- 拖拽.html &lt;project&gt; Created by my on 2015-11-22. Copyright 2015 my. All rights reserved. --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #div &#123;width:200px; height:200px; background:yellow; position:absolute;&#125; #div2 &#123;width:200px; height:200px; background:green; position:absolute;&#125; &lt;/style&gt; &lt;/head&gt; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; new Drag(&apos;div&apos;); new LimitDrag(&apos;div2&apos;); &#125;; &lt;/script&gt; &lt;body&gt; &lt;div id=&quot;div&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/drag.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/limitDrag.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/html&gt; /* * 作者：无双 * 时间：2015年11月22日 * 描述：拖拽 */ function Drag(id) &#123; var _this=this; this.disX=0; this.disY=0; this.oDiv=document.getElementById(id); this.oDiv.onmousedown=function (ev) &#123; _this.fnDown(ev); return false; &#125;; &#125;; Drag.prototype.fnDown=function (ev) &#123; var _this=this; var oEvent=ev||event; this.disX=oEvent.clientX-this.oDiv.offsetLeft; this.disY=oEvent.clientY-this.oDiv.offsetTop; document.onmousemove=function (ev) &#123; _this.fnMove(ev); &#125;; document.onmouseup=function () &#123; _this.fnUp(); &#125;; &#125;; Drag.prototype.fnMove=function (ev) &#123; var oEvent=ev||event; this.oDiv.style.left=oEvent.clientX-this.disX+&apos;px&apos;; this.oDiv.style.top=oEvent.clientY-this.disY+&apos;px&apos;; &#125;; Drag.prototype.fnUp=function () &#123; document.onmousemove=null; document.onmouseup=null; &#125;; /* * 作者：无双 * 时间：2015年11月22日 * 描述：限制范围拖拽 */ function LimitDrag(id) &#123; Drag.call(this, id); //继承属性 &#125; for(var i in Drag.prototype) &#123; LimitDrag.prototype[i]=Drag.prototype[i]; &#125; LimitDrag.prototype.fnMove=function (ev) &#123; var oEvent=ev||event; var l=oEvent.clientX-this.disX; var t=oEvent.clientY-this.disY; if(l&lt;0) &#123; l=0; &#125; else if(l&gt;document.documentElement.clientWidth-this.oDiv.offsetWidth) &#123; l=document.documentElement.clientWidth-this.oDiv.offsetWidth; &#125; this.oDiv.style.left=l+&apos;px&apos;; this.oDiv.style.top=t+&apos;px&apos;; &#125;;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"集财项目开发记录","slug":"2015-10-19-项目开发记录","date":"2015-12-21T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/22/2015-10-19-项目开发记录/","link":"","permalink":"http://yoursite.com/2015/12/22/2015-10-19-项目开发记录/","excerpt":"nodejs项目在使用handlebars时，改文件后缀的设置(主要是html文件)。1-1： 首先将views下面的html文件后缀改成’文件名.html’。（有的文件名是’xx.hbs，有的则不一定。。’）1-2：在app处增加如下代码： 123app.set(&apos;view engine&apos;, &apos;html&apos;);app.engine(&apos;html&apos;, require(&apos;hbs&apos;).__express); 判断微信以及IOS和安卓系统。","text":"nodejs项目在使用handlebars时，改文件后缀的设置(主要是html文件)。1-1： 首先将views下面的html文件后缀改成’文件名.html’。（有的文件名是’xx.hbs，有的则不一定。。’）1-2：在app处增加如下代码： 123app.set(&apos;view engine&apos;, &apos;html&apos;);app.engine(&apos;html&apos;, require(&apos;hbs&apos;).__express); 判断微信以及IOS和安卓系统。 node项目开发目前大致如下： node原生（使用c编写的http服务器） node 框架，（如express，使node开发更简单便捷。） mvc框架（如 EJS、juice、handlebars、jade等，也就是页面模板） 第三方插件（如jQuery、方便处理数据请求、元素选择、处理动画等） 在手机端使用viewport 就能使得页面自动缩放，适合移动端观看，少用固定宽高，再配合一些媒寻（@media）、百分比布局、rem（相对跟元素【html】的单位）、css3独有布局（盒子模型）、分栏布局等。 业务逻辑大致如下： controller部分（本质上就是路由部分）负责页面渲染，在内部使用node自带的数据请求，直接渲染到页面（使用res.render(页面目录,{数据：你要传到页面的数据})）。其他部分使用jq的ajax来处理数据。 想要全局得到数据，则用 window.数据= 你定义的数据。这样就能在全局获取 var 数据=window.数据，在node部分，使用req.session.自定义变量=自定义变量，要取时直接 var 变量= req.session.自定义变量。 页面之间，除了使用以上部分说的，还可以使用res.locals.自定义变量=自定义数据的方式来存或取。 nodejs项目在使用handlebars时，改文件后缀的设置(主要是html文件)。1-1： 首先将views下面的html文件后缀改成’文件名.html’。（有的文件名是’xx.hbs，有的则不一定。。’）1-2：在app处增加如下代码： 123app.set(&apos;view engine&apos;, &apos;html&apos;);app.engine(&apos;html&apos;, require(&apos;hbs&apos;).__express); 判断微信以及IOS和安卓系统。 1234567891011121314151617181920212223242526272829303132333435363738394041define(function(require, exports, module) &#123; require(&apos;jquery&apos;); function isWx() &#123; //判断微信系统 var browser = &#123; versions: function() &#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或uc浏览器 // iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 , //是否为iPhone或者QQHD浏览器 // iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad // webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language: (navigator.browserLanguage || navigator.language).toLowerCase() &#125; var ua = window.navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == &apos;micromessenger&apos;) &#123; //是微信，跳转到应用宝 $(&quot;.down-app&quot;).attr(&quot;href&quot;, &quot;http://a.app.qq.com/o/simple.jsp?pkgname=com.jc.jicai_android&quot;); &#125; else &#123; if (browser.versions.ios == true) &#123; //ios跳转到。。。 $(&quot;.down-app&quot;).attr(&quot;href&quot;, &quot;https://itunes.apple.com/cn/app/ji-cai/id1024955696&quot;); &#125; else if (browser.versions.android == true) &#123; //安卓跳转地址。。 $(&quot;.down-app&quot;).attr(&quot;href&quot;, &quot;/downloadAndroid&quot;); &#125; else &#123; //其他系统。。 $(&quot;.down-app&quot;).attr(&quot;href&quot;, &quot;/product/list&quot;); &#125; &#125; &#125; isWx();&#125;) 如何求一个数组之和。12345678$(document).ready(function() &#123; var arr = [1, 2, 3, 1, 2, 3, 34, 15,1,23,123,151,15125,151233,1516,152,231512,15]; var x = null; for (var i = 0; i &lt; arr.length; i++) &#123; x += arr[i]; console.log(x); &#125;&#125;) 集财注册js代码（自用）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268define(function(require, exports, module) &#123; require(&apos;jquery&apos;); function CreatedComReg() &#123; require(&apos;/js/jquery_md5&apos;); this.oText = $(&apos;#loadingText&apos;).val(); this.loadingHtml = &apos;\\ &lt;div id=&quot;parent&quot;&gt;\\ &lt;div id=&quot;loading&quot;&gt;\\ &lt;div id=&quot;circleG&quot;&gt;\\ &lt;div id=&quot;circleG_1&quot; class=&quot;circleG&quot;&gt;\\ &lt;/div&gt;\\ &lt;div id=&quot;circleG_2&quot; class=&quot;circleG&quot;&gt;\\ &lt;/div&gt;\\ &lt;div id=&quot;circleG_3&quot; class=&quot;circleG&quot;&gt;\\ &lt;/div&gt;\\ &lt;div id=&quot;loadingText&quot;&gt;\\ &lt;p&gt;&apos; + this.oText + &apos;&lt;/p&gt;\\ &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\\ &apos;; this.telReg = /1[3|5|7|8|][0-9]&#123;9&#125;/; //手机号码正则 this.mmsgSpeed = 3000; //提示信息显示时间 this.oTimer_mmsg = null; this.tel = $(&apos;#telephone&apos;).val(); //电话号码 this.code = $(&apos;#validateCode&apos;).val(); //验证码 this.psd = $(&apos;#passwd&apos;).val(); //密码 this.sendCodeBtn = $(&apos;#oSendCodeBtn&apos;); this.img = $(&apos;#oRandomImg&apos;); this.confirmBtn = $(&apos;#btn_Confirm&apos;); var This = this; this.sendStyleCtr(); this.btn_ConfirmCtr(); This.getImgFn(); //进来图片就加载 this.sendCodeBtn.click(function() &#123; //发送验证码 This.sendCodeBtnFn(); &#125;); this.confirmBtn.click(function() &#123; //发送验证码 This.confirmBtnFn(); &#125;); this.img.click(function() &#123; This.imgClick(); &#125;); // $(document.body).before(this.loadingHtml); &#125;; CreatedComReg.prototype.sendCodeBtnFn = function() &#123; var This = this; this.tel = $(&apos;#telephone&apos;).val(); //电话号码 if (this.tel.length &lt; 1) &#123; This.mmsg(&apos;请输入正确的手机号码&apos;); &#125; else if (!This.telReg.test(This.tel)) &#123; This.mmsg(&apos;手机号码格式错误&apos;); &#125; else &#123; var oImgCode = $(&apos;#imgCode&apos;).val(); if (!oImgCode || oImgCode.length &lt; 1) &#123; This.mmsg(&apos;图片验证码错误，点击刷新&apos;); &#125; else if (oImgCode &amp;&amp; oImgCode.length &lt; 4) &#123; This.mmsg(&apos;图片验证码错误，点击刷新&apos;); &#125; else &#123; This.verifyFn(); &#125; &#125;; &#125;; CreatedComReg.prototype.confirmBtnFn = function() &#123; var This = this; this.tel = $(&apos;#telephone&apos;).val(); //电话号码 if (This.tel.length &lt; 1) &#123; This.mmsg(&apos;请输入正确的手机号码&apos;); &#125; else if (!This.telReg.test(This.tel)) &#123; This.mmsg(&apos;手机号码格式错误&apos;); &#125; else &#123; var oImgCode = $(&apos;#imgCode&apos;).val(); if (!oImgCode || oImgCode.length &lt; 1) &#123; This.mmsg(&apos;请输入图片中的验证码&apos;); &#125; else if (oImgCode &amp;&amp; oImgCode.length &lt; 4) &#123; This.mmsg(&apos;请输入正确的图片验证码&apos;); &#125; else &#123; // sendCodeFn(); var oCode = $(&apos;#validateCode&apos;).val(); var oPsd = $(&apos;#passwd&apos;).val(); if (!oCode || oCode.length &lt; 1) &#123; This.mmsg(&apos;请输入正确的短信验证码&apos;); &#125; else if (oCode &amp;&amp; oCode.length &lt; 6) &#123; This.mmsg(&apos;请输入正确的短信验证码&apos;); &#125; else if (!oPsd || oPsd.length &lt; 1) &#123; This.mmsg(&apos;请输入6~16位密码&apos;); &#125; else if (oPsd &amp;&amp; oPsd &lt; 6) &#123; This.mmsg(&apos;请输入6~16位密码&apos;); &#125; else &#123; This.codeVerify(); &#125;; &#125;; &#125;; &#125;; //短信验证码校验 CreatedComReg.prototype.codeVerify = function() &#123; var This = this; var tel = $(&apos;#telephone&apos;).val(); //电话号码 var code = $(&apos;#validateCode&apos;).val(); //验证码 $.ajax(&#123; type: &quot;post&quot;, url: API_HOST + &quot;/api/msg/code/verify&quot;, dataType: &apos;jsonp&apos;, data: &#123; telephone: tel, code: code &#125;, success: function(v) &#123; if (v.err_code == &apos;0&apos;) &#123; $(&apos;form&apos;).attr(&apos;action&apos;, &apos;/register&apos;); $(&apos;form&apos;).submit(); $(document.body).before(This.loadingHtml); &#125; else &#123; This.mmsg(v.err_msg); &#125;; &#125;, async: true &#125;); &#125;; //发送验证码倒计时 CreatedComReg.prototype.sendCodeTime = function() &#123; var This = this; this.oSendCodeTimer = null; this.oSendCodeNum = 60; var oTime = 60; clearInterval(this.oSendCodeTimer); this.oSendCodeTimer = setInterval(function() &#123; if (This.oSendCodeNum &lt;= 0) &#123; This.oSendCodeNum = oTime; This.sendStyleCtr2(); $(&apos;#oSendCodeBtn&apos;).text(&apos;获取验证码&apos;); $(&apos;#oSendCodeBtn&apos;).attr(&apos;disabled&apos;, false); clearInterval(This.oSendCodeTimer); &#125; else &#123; This.oSendCodeNum--; $(&apos;form&apos;).off(); $(&apos;#oSendCodeBtn&apos;).attr(&apos;disabled&apos;, true); $(&apos;#oSendCodeBtn&apos;).css(&apos;background&apos;, &apos;rgb( 165, 165, 165)&apos;); $(&apos;#oSendCodeBtn&apos;).text(This.oSendCodeNum + &quot;s&quot;); &#125;; &#125;, 1000); &#125;; //发送验证码按钮状态控制 CreatedComReg.prototype.sendStyleCtr = function() &#123; var This = this; $(&apos;form&apos;).on(&apos;input propertychange&apos;, function() &#123; This.sendStyleCtr2(); &#125;); &#125;; //发送验证码按钮状态控制方法 CreatedComReg.prototype.sendStyleCtr2 = function() &#123; var This = this; var tel = $(&apos;#telephone&apos;).val(); this.telReg = /1[3|5|7|8|][0-9]&#123;9&#125;/; //手机号码正则 if (this.telReg.test(tel)) &#123; var oImgCode = $(&apos;#imgCode&apos;).val(); if (!oImgCode || $(&apos;#imgCode&apos;).val().length &lt; 4) &#123; $(&apos;#oSendCodeBtn&apos;).css(&apos;background&apos;, &apos;rgb( 165, 165, 165)&apos;); &#125; else &#123; $(&apos;#oSendCodeBtn&apos;).css(&apos;background&apos;, &apos;rgb( 165, 165, 165)&apos;); &#125;; &#125;; &#125;; //确认按钮样式控制 CreatedComReg.prototype.btn_ConfirmCtr = function() &#123; var This = this; $(&apos;form&apos;).on(&apos;input propertychange&apos;, function() &#123; This.btn_ConfirmCtr2(); &#125;); &#125;; //确认按钮样式控制 方法 CreatedComReg.prototype.btn_ConfirmCtr2 = function() &#123; this.telReg = /1[3|5|7|8|][0-9]&#123;9&#125;/; //手机号码正则 this.tel = $(&apos;#telephone&apos;).val(); //电话号码 this.code = $(&apos;#validateCode&apos;).val(); //验证码 this.psd = $(&apos;#passwd&apos;).val(); //密码 this.imgCode = $(&apos;#imgCode&apos;).val(); if (this.telReg.test(this.tel) &amp;&amp; this.code.length &gt; 5 &amp;&amp; this.psd.length &gt; 5 &amp;&amp; this.imgCode.length &gt; 3) &#123; $(&apos;#btn_Confirm&apos;).css(&apos;background-color&apos;, &apos;rgb( 255, 172, 42)&apos;) &#125; else &#123; $(&apos;#btn_Confirm&apos;).css(&apos;background-color&apos;, &apos;rgb( 255, 172, 42)&apos;) &#125;; &#125;; //发送验证码方法 CreatedComReg.prototype.sendCodeFn = function() &#123; var This = this; var tel = $(&apos;#telephone&apos;).val() //电话号码 var code = $(&apos;#validateCode&apos;).val(); //验证码 var psd = $(&apos;#passwd&apos;).val(); //密码 var oImgCode = $(&apos;#imgCode&apos;).val(); $.ajax(&#123; type: &quot;post&quot;, url: API_HOST + &quot;/api/msg/generateCode&quot;, dataType: &apos;jsonp&apos;, data: &#123; telephone: tel, key: this.key, imgCode: oImgCode &#125;, success: function(v) &#123; if (v.err_code == &apos;0&apos;) &#123; This.mmsg(&apos;验证码已发送&apos;); This.sendCodeTime(); &#125; else if (v.err_code != &apos;0&apos;) &#123; This.mmsg(v.err_msg); &#125;; &#125;, async: true &#125;); &#125;; CreatedComReg.prototype.verifyFn = function() &#123; var This = this; var tel = $(&apos;#telephone&apos;).val(); //电话号码 $.ajax(&#123; type: &quot;post&quot;, url: API_HOST + &quot;/api/validateTelephone&quot;, dataType: &apos;jsonp&apos;, data: &#123; telephone: tel &#125;, success: function(v) &#123; if (v.err_code == &apos;0&apos;) &#123; if (v.data.isExist == true) &#123; This.mmsg(&apos;该手机号码已经注册&apos;); &#125; else &#123; This.sendCodeFn(); &#125;; &#125; else &#123; This.mmsg(v.err_msg); &#125; &#125;, async: true &#125;); &#125;; CreatedComReg.prototype.mmsg = function(mmsg) &#123; //提示信息方法 var This = this; clearTimeout(This.oTimer_mmsg); $(&apos;#mmsg&apos;).val(&quot; &quot;); $(&apos;#mmsg&apos;).slideDown(&apos;slow&apos;, function() &#123; oTimer_mmsg = setTimeout(function() &#123; $(&apos;#mmsg&apos;).slideToggle(&apos;slow&apos;); &#125;, This.mmsgSpeed) $(&apos;#mmsg&apos;).val(mmsg); &#125;); &#125;; CreatedComReg.prototype.getImgFn = function() &#123; var This = this; this.date = new Date(); //时间 this.tiemTmp = this.date.getTime(); //时间戳 this.random = (Math.random() * 100).toString(); //随机数 this.key = $.md5(this.tiemTmp.toString() + this.random); // console.log(this.key) This.img.attr(&apos;src&apos;, API_HOST + &apos;/api/captcha/getImage&apos; + &apos;?key=&apos; + this.key); &#125;; CreatedComReg.prototype.imgClick = function() &#123; var This = this; This.getImgFn(); &#125;; new CreatedComReg();&#125;);","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"gulp、grunt与seajs的使用总结","slug":"2015-12-22-gulp、grunt与seajs的使用总结","date":"2015-12-21T16:00:00.000Z","updated":"2017-06-18T04:12:08.223Z","comments":true,"path":"2015/12/22/2015-12-22-gulp、grunt与seajs的使用总结/","link":"","permalink":"http://yoursite.com/2015/12/22/2015-12-22-gulp、grunt与seajs的使用总结/","excerpt":"","text":"前言：在构建中，使用seajs、gulp等混合使用时，会出现的便利和坑，记录于此！ gulp中文网：http://www.gulpjs.com.cn/ gulp官网：http://gulpjs.com/ grunt中文网：http://www.gruntjs.net/ grunt官网：http://gruntjs.com/ seajs官网：http://seajs.org/ seajs在github：https://github.com/seajs/seajs 尚在完善。。。","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"grunt","slug":"grunt","permalink":"http://yoursite.com/tags/grunt/"},{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"},{"name":"seajs","slug":"seajs","permalink":"http://yoursite.com/tags/seajs/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"nodeJS之socket.io","slug":"2015-12-22-nodeJS之socket.io","date":"2015-12-21T16:00:00.000Z","updated":"2017-06-18T04:11:55.084Z","comments":true,"path":"2015/12/22/2015-12-22-nodeJS之socket.io/","link":"","permalink":"http://yoursite.com/2015/12/22/2015-12-22-nodeJS之socket.io/","excerpt":"","text":"socket.io基于node.js并简化了WebSocket API，统一了各种通信API。 API文档参考：http://socket.io/ 参考链接1：http://www.cnblogs.com/dxy1982/archive/2012/01/30/2328020.html 参考链接2：http://www.cnblogs.com/flyoung2008/archive/2012/07/19/2600132.html …. 尚在完善中…..","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"socket.io","slug":"socket-io","permalink":"http://yoursite.com/tags/socket-io/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"mongoose","slug":"2015-12-22-mongoose","date":"2015-12-21T16:00:00.000Z","updated":"2017-06-18T04:12:00.478Z","comments":true,"path":"2015/12/22/2015-12-22-mongoose/","link":"","permalink":"http://yoursite.com/2015/12/22/2015-12-22-mongoose/","excerpt":"","text":"从听说node，到使用node，再到到node进阶中，遇到了许多坑，也收获了许多喜悦。此处是mongoose的学习、实践记录。 官网api链接：http://mongoosejs.com/docs/index.html 参考链接1：https://cnodejs.org/topic/504b4924e2b84515770103dd 参考链接2：http://www.html-js.com/article/Mongoose-based-mongoose-entry-a 内容有空再添加….尚在完善中。","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"js计算，输入参数即可计算昨天，今天，明天","slug":"2015-11-20-js计算时间","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:49.330Z","comments":true,"path":"2015/12/20/2015-11-20-js计算时间/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-11-20-js计算时间/","excerpt":"","text":"js计算，输入参数即可计算昨天，今天，明天 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;title&gt;js获取日期：前天、昨天、今天、明天、后天&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; Date.prototype.DateAdd = function(strInterval, Number) &#123; var dtTmp = this; switch (strInterval) &#123; case &apos;s&apos; :return new Date(Date.parse(dtTmp) + (1000 * Number)); case &apos;n&apos; :return new Date(Date.parse(dtTmp) + (60000 * Number)); case &apos;h&apos; :return new Date(Date.parse(dtTmp) + (3600000 * Number)); case &apos;d&apos; :return new Date(Date.parse(dtTmp) + (86400000 * Number)); case &apos;w&apos; :return new Date(Date.parse(dtTmp) + ((86400000 * 7) * Number)); case &apos;q&apos; :return new Date(dtTmp.getFullYear(), (dtTmp.getMonth()) + Number*3, dtTmp.getDate(), dtTmp.getHours(), dtTmp.getMinutes(), dtTmp.getSeconds()); case &apos;m&apos; :return new Date(dtTmp.getFullYear(), (dtTmp.getMonth()) + Number, dtTmp.getDate(), dtTmp.getHours(), dtTmp.getMinutes(), dtTmp.getSeconds()); case &apos;y&apos; :return new Date((dtTmp.getFullYear() + Number), dtTmp.getMonth(), dtTmp.getDate(), dtTmp.getHours(), dtTmp.getMinutes(), dtTmp.getSeconds()); &#125; &#125; function GetDateStr2(AddDayCount) &#123; var dd = new Date(); ddd = dd.DateAdd(&apos;d&apos;,AddDayCount);//三天后 var y = ddd.getFullYear(); var m = ddd.getMonth()+1;//获取当前月 var d = ddd.getDate(); return y+&quot;-&quot;+m+&quot;-&quot;+d; &#125; document.write(&quot;前天：&quot;+GetDateStr2(-2)); document.write(&quot;&lt;br /&gt;昨天：&quot;+GetDateStr2(-1)); document.write(&quot;&lt;br /&gt;今天：&quot;+GetDateStr2(0)); document.write(&quot;&lt;br /&gt;明天：&quot;+GetDateStr2(1)); document.write(&quot;&lt;br /&gt;后天：&quot;+GetDateStr2(2)); document.write(&quot;&lt;br /&gt;大后天：&quot;+GetDateStr2(3)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1234567891011121314151617181920var str1 = &apos;2010年9月16日&apos;;var str2 = &apos;2010-09-10&apos;;//用字符串分割, 精确到日function Days(day1, day2)&#123; var y1, y2, m1, m2, d1, d2;//year, month, day; y1 = parseInt(day1); y2 = parseInt(day2.split(&apos;-&apos;)[0]); m1 = parseInt(day1.split(&apos;年&apos;)[1].split(&apos;月&apos;)[0]); m2 = parseInt(day2.split(&apos;-&apos;)[1]); d1 = parseInt(day1.split(&apos;年&apos;)[1].split(&apos;月&apos;)[1].split(&apos;日&apos;)[0]); d2 = parseInt(day2.split(&apos;-&apos;)[2]); var date1 = new Date(y1, m1, d1); var date2 = new Date(y2, m2, d2); //用距标准时间差来获取相距时间 var minsec = Date.parse(date1) - Date.parse(date2); var days = minsec / 1000 / 60 / 60 / 24; //factor: second / minute / hour / day return days;&#125;alert(Days(str1, str2));","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"jquery","slug":"2015-11-16-jquery表单验证","date":"2015-12-19T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/20/2015-11-16-jquery表单验证/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-11-16-jquery表单验证/","excerpt":"jquery 注册 组件（自用）","text":"jquery 注册 组件（自用） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** * time：2015-11-16 10:57:09 * user：zhongciyisheng@live.com * tips：注册组件。 */define(function(require, exports, module) &#123; require(&apos;jquery&apos;); require(&apos;/js/jquery_md5&apos;); //md5 var oErrTextSpeed = 3000; var oErrTextTimer = null; var telReg = /1[3|5|7|8|][0-9]&#123;9&#125;/; //手机号码正则 var oTel = $(&apos;.ws_reg_tel&apos;).val(); var oPsd = $(&apos;.ws_reg_psd&apos;).val(); var oImgCode = $(&apos;.ws_reg_imgCode&apos;).val(); var oMsgCode = $(&apos;.ws_reg_msgCode&apos;).val(); var oImg = $(&apos;.ws_reg_img&apos;); var oSendBtn = $(&apos;.ws_reg_sendBtn&apos;); var oConfirmBtn = $(&apos;.ws_reg_confirmBtn&apos;); var oErrText = $(&apos;.ws_reg_errText&apos;); var aErrText = &#123; &quot;noTel&quot;: &quot;请输入手机号码&quot;, &quot;noImgCode&quot;: &quot;请输入图片验证码&quot;, &quot;errImgCode&quot;: &quot;图片验证码错误，点击刷新重新输入。&quot;, &quot;errTel&quot;: &quot;请输入正确的手机号码&quot;, &quot;isRegTel&quot;: &quot;该手机号码已经注册&quot;, &quot;noMsgCode&quot;: &quot;请输入短信验证码&quot;, &quot;errMsgCode&quot;: &quot;请输入正确的短信验证码&quot;, &quot;noPsd&quot;: &quot;请输入6～16位密码&quot;, &quot;errPsd&quot;: &quot;请输入6～16位密码&quot; &#125;; $(document).ready(function() &#123; init(); &#125;) function init() &#123; getImgFn(); imgClickFn(); sendBtnClickFn(); confirmBtnClickFn(); &#125;; function getImgFn() &#123; oDate = new Date(); //时间 oTimeStamp = oDate.getTime(); //时间戳 oRandom = (Math.random() * 100).toString(); //随机数 oKey = $.md5(oTimeStamp.toString() + oRandom); oImg.attr(&apos;src&apos;, API_HOST + &apos;/api/captcha/getImage&apos; + &apos;?key=&apos; + oKey); &#125;; //图片加载 function imgClickFn() &#123; oImg.click(function() &#123; //点击加载图片 getImgFn(); &#125;); &#125;; //验证码发送 function sendBtnClickFn() &#123; oSendBtn.click(function() &#123; var telReg = /1[3|5|7|8|][0-9]&#123;9&#125;/; //手机号码正则 var oTel = $(&apos;.ws_reg_tel&apos;).val(); var oImgCode = $(&apos;.ws_reg_imgCode&apos;).val(); if (oTel &amp;&amp; telReg.test(oTel)) &#123; if (oImgCode) &#123; if (oImgCode.length &lt; 4) &#123; errText(aErrText.errImgCode); &#125; else &#123; verifyFn(); &#125;; &#125; else &#123; errText(aErrText.noImgCode); &#125; &#125; else &#123; if (!oTel || oTel.length &lt; 1 || oTel == &apos;&apos;) &#123; errText(aErrText.noTel); &#125; else &#123; errText(aErrText.errTel); &#125;; &#125; &#125;) &#125;; //点击注册按钮 function confirmBtnClickFn() &#123; oConfirmBtn.click(function() &#123; var telReg = /1[3|5|7|8|][0-9]&#123;9&#125;/; //手机号码正则 var oTel = $(&apos;.ws_reg_tel&apos;).val(); var oPsd = $(&apos;.ws_reg_psd&apos;).val(); var oMsgCode = $(&apos;.ws_reg_msgCode&apos;).val(); var oImgCode = $(&apos;.ws_reg_imgCode&apos;).val(); if (!oTel) &#123; errText(aErrText.noTel); &#125; else if (!telReg.test(oTel)) &#123; errText(aErrText.errTel); &#125; else &#123; if (!oImgCode) &#123; errText(aErrText.noImgCode); &#125; else if (oImgCode.length &lt; 4) &#123; errText(aErrText.errImgCode); &#125; else &#123; if (!oMsgCode) &#123; errText(aErrText.noMsgCode); &#125; else if (oMsgCode.length &lt; 6) &#123; errText(aErrText.errMsgCode); &#125; else &#123; /**--------- 校验短信验证码 ------------**/ $.ajax(&#123; type: &quot;post&quot;, url: API_HOST + &quot;/api/msg/code/verify&quot;, dataType: &apos;jsonp&apos;, data: &#123; telephone: oTel, code: oMsgCode &#125;, success: function(v) &#123; if (v.err_code == &apos;0&apos;) &#123; /**--------- 成功时处理 ------------**/ if (!oPsd) &#123; errText(aErrText.noPsd); &#125; else if (oPsd.length &lt; 6) &#123; errText(aErrText.errPsd); &#125; else &#123; //最后一步，当以上全满足了，则允许表单提交 &#125; &#125; else &#123; /**--------- 失败时返回失败信息 ------------**/ errText(v.err_msg); &#125;; &#125;, async: true &#125;); &#125;; &#125;; &#125;; &#125;); &#125;; //检测是否已注册 function verifyFn() &#123; var oTel = $(&apos;.ws_reg_tel&apos;).val(); $.ajax(&#123; type: &quot;post&quot;, url: API_HOST + &quot;/api/validateTelephone&quot;, dataType: &apos;jsonp&apos;, data: &#123; telephone: oTel &#125;, success: function(v) &#123; if (v.err_code == &apos;0&apos;) &#123; if (v.data.isExist == true) &#123; errText(&apos;该手机号码已经注册&apos;); &#125; else &#123; sendCodeFn(); &#125;; &#125;; &#125;, async: true &#125;); &#125;; //发送验证码方法 function sendCodeFn() &#123; var oTel = $(&apos;.ws_reg_tel&apos;).val(); //电话号码 var oImgCode = $(&apos;.ws_reg_imgCode&apos;).val(); $.ajax(&#123; type: &quot;post&quot;, url: API_HOST + &quot;/api/msg/generateCode&quot;, dataType: &apos;jsonp&apos;, data: &#123; telephone: oTel, key: oKey, imgCode: oImgCode &#125;, success: function(v) &#123; if (v.err_code == &apos;0&apos;) &#123; errText(&apos;验证码已发送&apos;) // sendCodeTime(); &#125; else if (v.err_code != &apos;0&apos;) &#123; errText(v.err_msg); &#125;; &#125;, async: true &#125;); &#125;; function errText(a) &#123; $(&apos;.ws_reg_errText&apos;).text(&apos;&apos;); $(&apos;.ws_reg_errText&apos;).text(a); clearTimeout(oErrTextTimer); oErrTextTimer = setTimeout(function() &#123; $(&apos;.ws_reg_errText&apos;).text(&apos;&apos;); &#125;, oErrTextSpeed) &#125;;&#125;);","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"tab","slug":"2015-10-19-tab切换","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:03:55.187Z","comments":true,"path":"2015/12/20/2015-10-19-tab切换/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-10-19-tab切换/","excerpt":"","text":"jquery代码如下：html代码：12345678910&lt;ul class=&quot;tabs&quot; id=&quot;tabs01&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;current&quot;&gt;tab切换一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;tab切换二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;tab切换三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;container&quot; id=&quot;container01&quot;&gt; &lt;div class=&quot;con&quot;&gt;显示内容一&lt;/div&gt; &lt;div class=&quot;con&quot;&gt;显示内容二&lt;/div&gt; &lt;div class=&quot;con&quot;&gt;显示内容三&lt;/div&gt;&lt;/div&gt; jquery代码如下：1$(function()&#123; tabs($(&quot;#tabs01 a&quot;), $(&apos;#container01 .con&apos;)); &#125;) 下面的代码就是具体实现tabs的函数：123456789var tabs = function(tab, con)&#123; tab.click(function()&#123; var indx = tab.index(this); tab.removeClass(&apos;current&apos;); $(this).addClass(&apos;current&apos;); con.hide(); con.eq(indx).show(); &#125;) &#125; 下面js方法：css代码：(公用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style type=&quot;text/css&quot;&gt; .wrapper &#123; width: 600px; height: auto; margin: 0 auto;&#125;p &#123; margin: 0; padding: 0; color: #333333; font-family: 宋体; font-size: 12px;&#125;ul &#123; margin: 0; padding: 0; list-style-type: none; width: 500px; height: 16px; border-bottom: #DDDDDD solid 1px;&#125;li &#123; margin: 0; padding: 0; height: 16px; padding-left: 5px; padding-right: 10px; float: left; border-left: #FFFFFF solid 1px; border-right: #808080 solid 1px; font-family: Verdana, Geneva, sans-serif; font-size: 12px; color: #000000; background-color: #F4F4F4; cursor: pointer;&#125;.one &#123; width: 500px; padding-top: 20px; display: none;&#125;.blue &#123; color: #58A200; background-color: #8C5C5C;&#125;.white &#123; color: #000000; background-color: #F4F4F4;&#125;&lt;/style&gt; js方法：JS:方法一：12345678910&lt;script type=&quot;text/javascript&quot;&gt;function showTab(num) &#123; for (i = 0; i &lt; 3; i++) &#123; document.getElementById(&quot;tab&quot; + i).style.display = &quot;none&quot;; document.getElementById(&quot;id&quot; + i).className = &quot;white&quot;; &#125; document.getElementById(&quot;tab&quot; + num).style.display = &quot;block&quot;; document.getElementById(&quot;id&quot; + num).className = &quot;blue&quot;;&#125;&lt;/script&gt; 在这里先把tab0, tab1, tab2都设置成display:none, class属性为white, 然后再根据所传参数来设置成display:block, class为blue方法一的HTML:12345678910111213141516&lt;div class=&quot;wrapper&quot;&gt;&lt;ul&gt; &lt;li id=&quot;id0&quot; onclick=&quot;showTab(0)&quot; class=&quot;blue&quot;&gt;Javascript&lt;/li&gt; &lt;li id=&quot;id1&quot; onclick=&quot;showTab(1)&quot;&gt;Action Script&lt;/li&gt; &lt;li id=&quot;id2&quot; onclick=&quot;showTab(2)&quot;&gt;Photoshop&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;one&quot; id=&quot;tab0&quot; style=&quot;display:block&quot;&gt; &lt;p&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;one&quot; id=&quot;tab1&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;one&quot; id=&quot;tab2&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; JS:方法二：1234567891011121314151617181920212223&lt;script type=&quot;text/javascript&quot;&gt;function showTab(i, j) &#123; var x; var y; var l, m; for (l = 0; l &lt; 3; l++) &#123; x = document.getElementById(&quot;id&quot; + l); if (i == l) &#123; x.className = &quot;blue&quot;; &#125; else &#123; x.className = &quot;white&quot;; &#125; &#125; for (m = 0; m &lt; 3; m++) &#123; y = document.getElementById(&quot;tab&quot; + m); if (j == m) &#123; y.style.display = &quot;block&quot;; &#125; else &#123; y.style.display = &quot;none&quot;; &#125; &#125;&#125;&lt;/script&gt; 方法二的HTML代码：12345678910111213141516&lt;div class=&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li id=&quot;id0&quot; onclick=&quot;showTab(0,0)&quot; class=&quot;blue&quot;&gt;Javascript&lt;/li&gt; &lt;li id=&quot;id1&quot; onclick=&quot;showTab(1,1)&quot;&gt;Action Script&lt;/li&gt; &lt;li id=&quot;id2&quot; onclick=&quot;showTab(2,2)&quot;&gt;Photoshop&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;one&quot; id=&quot;tab0&quot; style=&quot;display:block&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;two&quot; id=&quot;tab1&quot; style=&quot;display:none&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;three&quot; id=&quot;tab2&quot; style=&quot;display:none&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 注意这种方法不能去掉l,m, 直接写成for (i=0; i&lt;3; i++), for (j=0; j&lt;3; j++)因为i原本是函数的参数，它的值是外面传进来的，如果将for (l=0; l&lt;3; l++)换成for (i=0; i&lt;3; i++)的话，i就被重新赋值了，showTab(0,0)、showTab(1,1)、showTab(1,2)括号里无论传任何值都没有区别了 ####方法三：html代码如下：123456789101112131415&lt;div class=&quot;wrap&quot;&gt; &lt;ul id=&quot;tag&quot;&gt; &lt;li class=&quot;current&quot;&gt;标签一&lt;/li&gt; &lt;li&gt;标签二&lt;/li&gt; &lt;li&gt;标签三&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;tagContent&quot;&gt; &lt;div&gt; 内容一 &lt;br&gt;内容一 &lt;/div&gt; &lt;div&gt; 内容二 &lt;br&gt;内容二 &lt;/div&gt; &lt;div&gt; 内容三 &lt;br&gt;内容三 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 *&#123;margin:0;padding:0;&#125; .wrap&#123;width:500px; margin:10px auto; &#125; #tag&#123; width:498px; overflow:hidden; background:#000; border:1px solid #000; &#125; #tag li&#123;list-style:none; float:left; margin-right:0px; color:white; padding:5px 20px; cursor:pointer;&#125; #tag .current&#123; color:#000; background:#ccc; &#125; #tagContent div&#123; width:498px; border:1px solid #000; border-top:none; height:300px; display:none; &#125; function tabs(title,content)&#123; var tag=document.getElementById(title).children; //获取Tag下的li，即Tag标签 var content=document.getElementById(content).children; //获取Tag标签对应的内容 content[0].style.display = &quot;block&quot;; //默认显示第一个标签的内容 var len= tag.length; for(var i=0; i&lt;len; i++) //无论点击谁都能实现当前显示，其余隐藏 &#123; tag[i].number=i; tag[i].onclick = function() //0级DOM的事件句柄注册 &#123; for(var n=0; n&lt;len; n++) &#123; tag[n].className=&quot;&quot;; content[n].style.display=&quot;none&quot;; &#125; //首先将全部的div隐藏 tag[this.number].className = &quot;current&quot;; content[this.number].style.display = &quot;block&quot;; &#125; &#125; &#125;; tabs(&quot;tag&quot;,&quot;tagContent&quot;);//你想实现tab切换的某一个实例。上面用到了chidren，可以用childNodes来实现该方法，但是要去除里面空白节点。代码如下：（加黑处就是去除空白节点）function tabs(title,content)&#123; var tag=document.getElementById(title).childNodes; console.log(tag.length);// 打印结果为7 for(var i=0;i&lt;tag.length;i++)&#123; if(tag[i].nodeType==3&amp;&amp;/\\s/.test(tag[i].nodeValue))&#123; tag[i].parentNode.removeChild(tag[i]); &#125; &#125; console.log(tag.length);// 打印结果为3 var content=document.getElementById(content).childNodes; console.log(content.length);// 打印结果为7 for(var i=0;i&lt;content.length;i++)&#123; if(content[i].nodeType==3&amp;&amp;/\\s/.test(content[i].nodeValue))&#123; content[i].parentNode.removeChild(content[i]); &#125; &#125; console.log(content.length);// 打印结果为3 content[0].style.display = &quot;block&quot;; //默认显示第一个标签的内容 var len= tag.length; for(var i=0; i&lt;len; i++) //无论点击谁都能实现当前显示，其余隐藏 &#123; tag[i].number=i; tag[i].onclick = function() //0级DOM的事件句柄注册 &#123; for(var n=0; n&lt;len; n++) &#123; tag[n].className=&quot;&quot;; content[n].style.display=&quot;none&quot;; &#125; //首先将全部的div隐藏 //console.log(this.number); tag[this.number].className = &quot;current&quot;; content[this.number].style.display = &quot;block&quot;; &#125; &#125; &#125;; tabs(&quot;tag&quot;,&quot;tagContent&quot;);","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"tab","slug":"tab","permalink":"http://yoursite.com/tags/tab/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"ajax","slug":"2015-12-04-ajax","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:32.321Z","comments":true,"path":"2015/12/20/2015-12-04-ajax/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-12-04-ajax/","excerpt":"","text":"12345678910111213141516##jquery的ajax： $.ajax(&#123; url: &apos;getTwitterFollowers.php&apos;, type: &apos;post&apos;,//GET,POST dataType:&apos;jsonp&apos;,//html,xml,json,jsonp.... data: &#123;&#125;,//需要的参数 success: function(data) &#123;//请求成功后处理函数 $(&apos;#ajaxphp-results&apos;).html(data); &#125;, error: function(e) &#123;//失败事的回调 //called when there is an error //console.log(e.message); &#125; &#125;); js原生的ajax：1234567891011121314151617181920212223242526272829303132333435363738var xhr = null; //1-- 创建ajax对象if (window.XMLHttpRequest) &#123; xhr = XMLHttpRequest();&#125; else &#123; //为了兼容IE6 xhr = ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125;;//2.连接服务器open(方法GET/POST，请求地址， 异步传输) xhr.open(&apos;GET&apos;, &apos;请求数据的地址&apos;, true /*true是阻塞模式*/ );xhr.send(); //3 发送请求xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; /* ** Http状态码 ** 1xx ：信息展示 ** 2xx ：成功 ** 3xx ：重定向 ** 4xx : 客户端错误 ** 5xx ：服务器端错误 */ if (xhr.status == 200) &#123; success(xhr.responseText); &#125; else &#123; if (failed) &#123; failed(xhr.status); &#125;; &#125;; &#125;;&#125;;// 处理返回数据/* ** 每当readyState改变时，就会触发onreadystatechange事件 ** readyState属性存储有XMLHttpRequest的状态信息 ** 0 ：请求未初始化 ** 1 ：服务器连接已建立 ** 2 ：请求已接受 ** 3 : 请求处理中 ** 4 ：请求已完成，且相应就绪 */ 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function Ajax(type, url, data, success, failed) &#123;// 创建ajax对象var xhr = null;if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;)&#125;var type = type.toUpperCase();// 用于清除缓存var random = Math.random();if (typeof data == &apos;object&apos;) &#123; var str = &apos;&apos;; for (var key in data) &#123; str += key + &apos;=&apos; + data[key] + &apos;&amp;&apos;; &#125; data = str.replace(/&amp;$/, &apos;&apos;);&#125;if (type == &apos;GET&apos;) &#123; if (data) &#123; xhr.open(&apos;GET&apos;, url + &apos;?&apos; + data, true); &#125; else &#123; xhr.open(&apos;GET&apos;, url + &apos;?t=&apos; + random, true); &#125; xhr.send();&#125; else if (type == &apos;POST&apos;) &#123; xhr.open(&apos;POST&apos;, url, true); // 如果需要像 html 表单那样 POST 数据，请使用 setRequestHeader() 来添加 http 头。 xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(data);&#125;// 处理返回数据xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; success(xhr.responseText); &#125; else &#123; if (failed) &#123; failed(xhr.status); &#125; &#125; &#125;&#125;&#125;// 测试调用var sendData = &#123; name: &apos;asher&apos;, sex: &apos;male&apos;&#125;;Ajax(&apos;get&apos;, &apos;data/data.html&apos;, sendData, function(data) &#123; console.log(data);&#125;, function(error) &#123; console.log(error);&#125;);","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"倒计时函数封装","slug":"2015-11-20-验证码组件","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:44.078Z","comments":true,"path":"2015/12/20/2015-11-20-验证码组件/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-11-20-验证码组件/","excerpt":"","text":"倒计时函数封装 12345678910111213141516171819202122232425262728293031323334353637define(function(require, exports, module) &#123; function Countdown(countButton)&#123; this.countButton = countButton; this.oSendCodeTimer = undefined; this.oSendCodeNum = 60; this.isStart = false; this.start = function()&#123; if(this.isStart)&#123; return; &#125; this.isStart = true; var _this = this; this.oSendCodeTimer = setInterval(function() &#123; if (_this.oSendCodeNum &lt; 1) &#123; _this.countButton.val(&apos;获取验证码&apos;); _this.countButton.attr(&apos;disabled&apos;, false); clearInterval(_this.oSendCodeTimer); &#125; else &#123; _this.oSendCodeNum--; _this.countButton.attr(&apos;disabled&apos;, true); _this.countButton.val(_this.oSendCodeNum + &quot; s&quot;); &#125;; &#125;, 1000); &#125; this.stop = function()&#123; if(this.isStart &amp;&amp; this.oSendCodeTimer)&#123; this.oSendCodeNum = 60; this.countButton.val(&apos;获取验证码&apos;); clearInterval(this.oSendCodeTimer); &#125; &#125; &#125; module.exports =Countdown;&#125;)","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"grunt","slug":"2015-12-04-grunt整合版[30分钟学会grunt]","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:26.490Z","comments":true,"path":"2015/12/20/2015-12-04-grunt整合版[30分钟学会grunt]/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-12-04-grunt整合版[30分钟学会grunt]/","excerpt":"","text":"说明：引用来源：【grunt整合版】30分钟学会使用grunt打包前端代码 grunt是一套前端自动化工具，一个基于nodeJs的命令行工具，一般用于：① 压缩文件 ② 合并文件 ③ 简单语法检查对于其他用法，我还不太清楚，我们这里简单介绍下grunt的压缩、合并文件，初学，有误请包涵 ##准备阶段 1、nodeJs环境因为grunt是基于nodeJs的，所以首先各位需要安装nodeJS环境，这块我们便不管了http://www.cnblogs.com/yexiaochai/p/3527418.html 2、安装grunt有了nodeJs环境后，我们便可以开始搞grunt了，因为我们可能在任何目录下运行打包程序，所以我们需要安装CLI官方推荐在全局安装CLI（grunt的命令行接口） 1npm install -g grunt-cli 这条命令将会把grunt命令植入系统路径，这样就能在任意目录运行他，原因是每次运行grunt时，它都会使用node的require查找本地是否安装grunt，如果找到CLI便加载这个本地grunt库然后应用我们项目中的GruntFile配置，并执行任务PS：这段先不要管，安装完了往下看 实例学习：打包zepto 一些东西说多了都是泪，直接先上实例吧，实例结束后再说其它的首先在D盘新建一个项目（文件夹就好）在里面新增两个文件（不要问为什么，搞进去先） ① package.json 12345678910111213141516171819&#123; &quot;name&quot;: &quot;demo&quot;, &quot;file&quot;: &quot;zepto&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;demo&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.1&quot;, &quot;grunt-contrib-requirejs&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-copy&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;, &quot;grunt-strip&quot;: &quot;~0.2.1&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;3.x&quot; &#125;&#125; ② Gruntfile.js完了我们需要在grunt目录下执行 npm install将相关的文件下载下来： 12$ cd d:$ cd grunt 然后我们的目录就会多一点东西： 多了很多东西，先别管事干什么的，我们后面都会用到，这个时候在目录下新建src文件夹，并且搞一个zepto进去 然后在Gruntfile中新增以下代码（先别管，增加再说） 12345678910111213141516171819module.exports = function (grunt) &#123; // 项目配置 grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), uglify: &#123; options: &#123; banner: &apos;/*! &lt;%= pkg.file %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&apos; &#125;, build: &#123; src: &apos;src/&lt;%=pkg.file %&gt;.js&apos;, dest: &apos;dest/&lt;%= pkg.file %&gt;.min.js&apos; &#125; &#125; &#125;); // 加载提供&quot;uglify&quot;任务的插件 grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); // 默认任务 grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);&#125; 然后运行 grunt命令后 grunt 嗯嗯，多了一个文件，并且是压缩的，不差！！！第一步结束 认识Gruntdile与package.json不出意外，每一个gurnt都会需要这两个文件，并且很可能就只有这两个文件（复杂的情况有所不同） package.json 这个文件用来存储npm模块的依赖项（比如我们的打包若是依赖requireJS的插件，这里就需要配置）然后，我们会在里面配置一些不一样的信息，比如我们上面的file，这些数据都会放到package中对于package的灵活配置，我们会在后面提到 Gruntfile 这个文件尤其关键，他一般干两件事情：① 读取package信息② 插件加载、注册任务，运行任务（grunt对外的接口全部写在这里面） Gruntfile一般由四个部分组成① 包装函数这个包装函数没什么东西，意思就是我们所有的代码必须放到这个函数里面 123module.exports = function (grunt) &#123;//你的代码&#125; 这个不用知道为什么，直接将代码放入即可 ② 项目/任务配置我们在Gruntfile一般第一个用到的就是initConfig方法配置依赖信息 1pkg: grunt.file.readJSON(&apos;package.json&apos;) 这里的 grunt.file.readJSON就会将我们的配置文件读出，并且转换为json对象 然后我们在后面的地方就可以采用pkg.XXX的方式访问其中的数据了值得注意的是这里使用的是underscore模板引擎，所以你在这里可以写很多东西 uglify是一个插件的，我们在package依赖项进行了配置，这个时候我们为系统配置了一个任务uglify（压缩），他会干这几个事情：① 在src中找到zepto进行压缩（具体名字在package中找到）② 找到dest目录，没有就新建，然后将压缩文件搞进去③ 在上面加几个描述语言这个任务配置其实就是一个方法接口调用，按照规范来就好，暂时不予关注，内幕后期来这里只是定义了相关参数，但是并未加载实际函数，所以后面马上就有一句： 1grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); 用于加载相关插件 最后注册一个自定义任务（其实也是默认任务），所以我们下面的命令行是等效的： 1grunt == grunt uglify 至此，我们就简单解析了一番grunt的整个操作，下面来合并文件的例子 合并文件合并文件依赖于grunt-contrib-concat插件，所以我们的package依赖项要新增一项 12345678910&quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;, &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.1&quot;, &quot;grunt-contrib-requirejs&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-copy&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;, &quot;grunt-strip&quot;: &quot;~0.2.1&quot;&#125;, 然后再将代码写成这个样子 123456789101112131415161718module.exports = function (grunt) &#123; // 项目配置 grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), concat: &#123; options: &#123; separator: &apos;;&apos; &#125;, dist: &#123; src: [&apos;src/zepto.js&apos;, &apos;src/underscore.js&apos;, &apos;src/backbone.js&apos;], dest: &apos;dest/libs.js&apos; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;); // 默认任务 grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;]);&#125; 运行后，神奇的一幕发生了：三个文件被压缩成了一个，但是没有压缩，所以，我们这里再加一步操作，将之压缩后再合并 12345678910111213141516171819202122232425module.exports = function (grunt) &#123; // 项目配置 grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), concat: &#123; options: &#123; separator: &apos;;&apos; &#125;, dist: &#123; src: [&apos;src/zepto.js&apos;, &apos;src/underscore.js&apos;, &apos;src/backbone.js&apos;], dest: &apos;dest/libs.js&apos; &#125; &#125;, uglify: &#123; build: &#123; src: &apos;dest/libs.js&apos;, dest: &apos;dest/libs.min.js&apos; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;); // 默认任务 grunt.registerTask(&apos;default&apos;, [&apos;concat&apos;, &apos;uglify&apos;]);&#125; 我这里的做法是先合并形成一个libs，然后再将libs压缩成libs.min.js所以我们这里换个做法，先压缩再合并，其实unglify已经干了这些事情了 12345678910111213141516module.exports = function (grunt) &#123; // 项目配置 grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), uglify: &#123; &quot;my_target&quot;: &#123; &quot;files&quot;: &#123; &apos;dest/libs.min.js&apos;: [&apos;src/zepto.js&apos;, &apos;src/underscore.js&apos;, &apos;src/backbone.js&apos;] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); // 默认任务 grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);&#125; 所以，我们就暂时不去关注concat了 最后，今天时间不早了，我们最后研究下grunt配合require于是便结束今天的学习吧 合并requireJS管理的文件 有了前面基础后，我们来干一件平时很头疼的事情，便是将require管理的所有js文件给压缩了合并为一个文件首先我们建立一个简单的程序，里面使用了zepto、backbone、underscore（事实上我并未使用什么）在main.js中新增代码： 12345678910111213141516171819202122232425require.config(&#123; baseUrl: &apos;&apos;, shim: &#123; $: &#123; exports: &apos;zepto&apos; &#125;, _: &#123; exports: &apos;_&apos; &#125;, B: &#123; deps: [ &apos;_&apos;, &apos;$&apos; ], exports: &apos;Backbone&apos; &#125; &#125;, paths: &#123; &apos;$&apos;: &apos;src/zepto&apos;, &apos;_&apos;: &apos;src/underscore&apos;, &apos;B&apos;: &apos;src/backbone&apos; &#125;&#125;);requirejs([&apos;B&apos;], function (b) &#123;&#125;); 这样的话运行会自动加载几个文件，我们现在希望将之合并为一个libs.js该怎么干呢？？？ 我们这里使用自定义任务方法来做，因为我们好像没有介绍他 要使用requireJS相关需要插件 grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); 因为我们以后可能存在配置文件存在各个项目文件的情况，所以我们这里将requireJs相关的配置放入gruntCfg.json中 这样我们的package.json就没有什么实际意义了： 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;demo&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;, &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.1&quot;, &quot;grunt-contrib-requirejs&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-copy&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;, &quot;grunt-strip&quot;: &quot;~0.2.1&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;3.x&quot; &#125;&#125; 我们这里设置的require相关的grunt配置文件如下（gruntCfg.json）：123456789101112131415161718192021222324&#123; &quot;requirejs&quot;: &#123; &quot;main&quot;: &#123; &quot;options&quot;: &#123; &quot;baseUrl&quot;: &quot;&quot;, &quot;paths&quot;: &#123; &quot;$&quot;: &quot;src/zepto&quot;, &quot;_&quot;: &quot;src/underscore&quot;, &quot;B&quot;: &quot;src/backbone&quot;, &quot;Test&quot;: &quot;src/Test&quot; &#125;, &quot;web&quot;: &#123; &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;Test&quot; ], &quot;out&quot;: &quot;dest/libs.js&quot; &#125; &#125; &#125; &#125;&#125; 这里我们要打包这些文件搞到dest的libs.js文件中，这个文件照做就行，最后核心代码如下： 12345678910111213141516171819202122232425262728293031module.exports = function (grunt) &#123; grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); //为了介绍自定义任务搞了一个这个 grunt.registerTask(&apos;build&apos;, &apos;require demo&apos;, function () &#123; //任务列表 var tasks = [&apos;requirejs&apos;]; //源码文件 var srcDir = &apos;src&apos;; //目标文件 var destDir = &apos;dest&apos;; //设置参数 grunt.config.set(&apos;config&apos;, &#123; srcDir: srcDir, destDir: destDir &#125;); //设置requireJs的信息 var taskCfg = grunt.file.readJSON(&apos;gruntCfg.json&apos;); var options = taskCfg.requirejs.main.options, platformCfg = options.web, includes = platformCfg.include, paths = options.paths; var pos = -1; var requireTask = taskCfg.requirejs; options.path = paths; options.out = platformCfg.out; options.include = includes; //运行任务 grunt.task.run(tasks); grunt.config.set(&quot;requirejs&quot;, requireTask); &#125;);&#125; 搞完了运行就好：grunt build 1grunt build 最后发现叶小钗三字，我就放心了，安全！！！！！！ ##配置任务/grunt.initConfig 前面我们简单的介绍了grunt相关的知识，这里我们这里还需要再熟悉下Gruntfile相关的知识点，比如说配置任务 grunt的任务配置都是在Gruntfile中的grunt.initConfig方法中指定的，这个配置主要都是一些命名性属性比如我们上次用到的合并以及压缩的任务配置： 1234567891011grunt.initConfig(&#123; concat: &#123; //这里是concat任务的配置信息 &#125;, uglify: &#123; //这里是uglify任务的配置信息 &#125;, //任意非任务特定属性 my_property: &apos;whatever&apos;, my_src_file: [&apos;foo/*.js&apos;, &apos;bar/*.js&apos;]&#125;); 其中的my_property完全可能读取外部json配置文件，然后在上面任务配置中便可以，比如我们要压缩的文件为准或者最后要放到哪里，便可以在此配置 我们使用grunt的时候，主要工作就是配置任务或者创建任务，实际上就是做一个事件注册，然后由我们触发之，所以grunt的核心还是事件注册每次运行grunt时，我们可以指定运行一个或者多个任务，通过任务决定要做什么，比如我们同时要压缩和合并还要做代码检查1grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;,&apos;qunit&apos;,&apos;concat&apos;,&apos;uglify&apos;]); 当运行一个基本任务时，grunt并不会查找配置和检查运行环境，他仅仅运行指定的任务函数，可以传递冒号分割参数，比如： 1234567grunt.registerTask(&apos;foo&apos;, &apos;A sample task that logs stuff.&apos;, function (arg1, arg2) &#123; if (arguments.length === 0) &#123; grunt.log.writeln(this.name + &quot;, no args&quot;); &#125; else &#123; grunt.log.writeln(this.name + &quot;, &quot; + arg1 + &quot; &quot; + arg2); &#125;&#125;); 运行结果如下： 1234567891011$ grunt foo:testing:123Running &quot;foo:testing:123&quot; (foo) taskfoo, testing 123$ grunt foo:testingRunning &quot;foo:testing&quot; (foo) taskfoo, testing undefined$ grunt fooRunning &quot;foo&quot; taskfoo, no args 这里有个多任务的情况，就是一个任务里面实际上第一了多个东东，这个时候就有所不同 12345678910grunt.initConfig(&#123; log: &#123; demo01: [1,2,3], demo02: &apos;hello world&apos;, demo03: false &#125;&#125;);grunt.registerTask(&apos;log&apos;,&apos;log stuff.&apos;, function()&#123; grunt.log.writeln(this.target + &apos;: &apos; + this.data);&#125;); 如果我们运行，运行情况如下： ??????? 更多时候，我们实际场景中都会需要自定义任务，而在我们任务内部使用 grunt.task.run({}) 运行任务这块的知识点，我们后面以实际例子说明 grunt插件学习grunt主要就是学习grunt的插件使用，所以我们今天先来学习常用的几个插件 1grunt-contrib-unglify 我们仍然以简单例子学习 123456789101112module.exports = function (grunt) &#123; grunt.initConfig(&#123; uglify: &#123; my_target: &#123; files: &#123; &apos;dest/libs.min.js&apos;: [&apos;src/zepto.js&apos;, &apos;src/underscoce.js&apos;] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);&#125; 这样会将src里面的zepto等文件打包值dest的lib.min.js中 压缩一个文件夹的所有文件 然后这段代码非常有意思，他会将一个文件目录里面的所有js文件打包到另一个文件夹 123456789101112131415module.exports = function (grunt) &#123; grunt.initConfig(&#123; uglify: &#123; my_target: &#123; files: [&#123; expand: true, cwd: &apos;src&apos;, src: &apos;**/*.js&apos;, dest: &apos;dest&apos; &#125;] &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);&#125; 若是你希望给你文件的头部加一段注释性语言配置banner信息即可 12345678910111213grunt.initConfig(&#123; pkg: grunt.file.readJSON(&apos;package.json&apos;), uglify: &#123; options: &#123; banner: &apos;/*! 注释信息 */&apos; &#125;, my_target: &#123; files: &#123; &apos;dest/output.min.js&apos;: [&apos;src/input.js&apos;] &#125; &#125; &#125;&#125;); 1grunt-contrib-concat 该插件主要用于代码合并，将多个文件合并为一个，我们前面的uglify也提供了一定合并的功能在可选属性中我们可以设置以下属性：① separator 用于分割各个文件的文字，② banner 前面说到的文件头注释信息，只会出现一次③ footer 文件尾信息，只会出现一次④ stripBanners去掉源代码注释信息（只会清楚/**/这种注释） 一个简单的例子： 1234567891011121314151617module.exports = function (grunt) &#123; grunt.initConfig(&#123; concat: &#123; options: &#123; separator: &apos;/*分割*/&apos;, banner: &apos;/*测试*/&apos;, footer: &apos;/*footer*/&apos; &#125;, dist: &#123; src: [&apos;src/zepto.js&apos;, &apos;src/underscore.js&apos;, &apos;src/backbone.js&apos;], dest: &apos;dist/built.js&apos;, &#125; &#125;&#125;); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);&#125; 合并三个文件为一个，这种在我们源码调试时候很有意义 构建两个文件夹 有时候我们可能需要将合并的代码放到不同的文件，这个时候可以这样干123456789101112131415module.exports = function (grunt) &#123; grunt.initConfig(&#123; concat: &#123; basic: &#123; src: [&apos;src/zepto.js&apos;], dest: &apos;dest/basic.js&apos; &#125;, extras: &#123; src: [&apos;src/underscore.js&apos;, &apos;src/backbone.js&apos;], dest: &apos;dest/with_extras.js&apos; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);&#125; 这种功能还有这样的写法： 12345678910111213module.exports = function (grunt) &#123; grunt.initConfig(&#123; concat: &#123; basic_and_extras: &#123; files: &#123; &apos;dist/basic.js&apos;: [&apos;src/test.js&apos;, &apos;src/zepto.js&apos;], &apos;dist/with_extras.js&apos;: [&apos;src/underscore.js&apos;, &apos;src/backbone.js&apos;] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);&#125; 第二种写法便于使用配置文件，具体各位选取吧，至于读取配置文件的东西我们这里就先不关注了 grunt-contrib-jshint 该插件用于检测文件中的js语法问题，比如我test.js是这样写的： 1alert(&apos;我是叶小钗&apos;) 12345678module.exports = function (grunt) &#123; grunt.initConfig(&#123; jshint: &#123; all: [&apos;src/test.js&apos;] &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);&#125; 运行结果是： 12345$ grunt jshintRunning &quot;jshint:all&quot; (jshint) taskLinting src/test.js ...ERROR[L1:C15] W033: Missing semicolon.alert(&apos;我是叶小钗&apos;) 说我缺少一个分号，好像确实缺少…..如果在里面写明显的BUG的话会报错多数时候，我们认为没有分号无伤大雅，所以，我们文件会忽略这个错误： 123456jshint: &#123; options: &#123; &apos;-W033&apos;: true &#125;, all: [&apos;src/test.js&apos;]&#125; 这里有一个稍微复杂的应用，就是我们合并之前做一次检查，合并之后再做一次检查，我们可以这样写 12345678910111213141516171819module.exports = function (grunt) &#123; grunt.initConfig(&#123; concat: &#123; dist: &#123; src: [&apos;src/test01.js&apos;, &apos;src/test02.js&apos;], dest: &apos;dist/output.js&apos; &#125; &#125;, jshint: &#123; options: &#123; &apos;-W033&apos;: true &#125;, pre: [&apos;src/test01.js&apos;, &apos;src/test02.js&apos;], after: [&apos;dist/output.js&apos;] &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);&#125; 1234567$ grunt jshint:pre concat jshint:afterRunning &quot;jshint:pre&quot; (jshint) task&gt;&gt; 2 files lint free.Running &quot;concat:dist&quot; (concat) taskFile &quot;dist/output.js&quot; created.Running &quot;jshint:after&quot; (jshint) task&gt;&gt; 1 file lint free. 这里连续运行了三个任务，先做检查再合并，然后做检测，我这里写了两个简单的文件，如果将jquery搞进去的话，好像还出了不少BUG……所以真的要用它还要自定一些规范，我们这里暂时到这里，先进入下一个插件学习 grunt-contrib-requirejs 我们的grunt打包程序极有可能与requirejs一起使用，但是几个插件学习下来又属requireJs的使用最为麻烦，因为网上资源很少，搞到这一段耗掉了我很多精力 这个时候你就会感叹，英语好不一定编程好，英语差想成为高手还是不简单啊！！！ 12345678910requirejs: &#123; compile: &#123; options: &#123; baseUrl: &quot;path/to/base&quot;, mainConfigFile: &quot;path/to/config.js&quot;, name: &quot;path/to/almond&quot;, // assumes a production build using almond out: &quot;path/to/optimized.js&quot; &#125; &#125;&#125; 官方的例子首先就是这几个属性： baseUrl 代表所有的js文件都会相对于这个目录 mainConfigFile 配置文件目录 name ？？？ out 输出文件 一些参数我们不太了解，这个时候就只能以例子破之了 12345678910111213141516171819202122232425module.exports = function (grunt) &#123; grunt.initConfig(&#123; requirejs: &#123; compile: &#123; &quot;options&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;$&quot;: &quot;src/zepto&quot;, &quot;_&quot;: &quot;src/underscore&quot;, &quot;B&quot;: &quot;src/backbone&quot;, &quot;Test&quot;: &quot;src/Test01&quot; &#125;, &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;Test&quot; ], &quot;out&quot;: &quot;dest/libs.js&quot; &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;);&#125; 这样配置后，会将include里面的文件打包为out对应的文件，paths的本身意义不大，就是用于配置include里面的指向 这个时候我们来加个name看看有神马作用 1234567891011121314151617181920212223242526module.exports = function (grunt) &#123; grunt.initConfig(&#123; requirejs: &#123; compile: &#123; &quot;options&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;name&quot;: &apos;src/test02.js&apos;, &quot;paths&quot;: &#123; &quot;$&quot;: &quot;src/zepto&quot;, &quot;_&quot;: &quot;src/underscore&quot;, &quot;B&quot;: &quot;src/backbone&quot;, &quot;Test&quot;: &quot;src/Test01&quot; &#125;, &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;Test&quot; ], &quot;out&quot;: &quot;dest/libs.js&quot; &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;);&#125; 然后，这里我们便不是有initConfig的做法了，直接使用自定义任务 1234567891011121314151617181920module.exports = function (grunt) &#123; grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); grunt.registerTask(&apos;build&apos;, &apos;require demo&apos;, function () &#123; //第一步，读取配置信息 var cfg = grunt.file.readJSON(&apos;cfg.json&apos;); cfg = cfg.requirejs; grunt.config.set(&apos;requirejs&apos;, &#123; test: cfg &#125;); //第二步，设置参数 grunt.log.debug(&apos;参数：&apos; + JSON.stringify(grunt.config())); //第三步跑任务 grunt.task.run([&apos;requirejs&apos;]); &#125;);&#125; 123456789101112131415161718$ grunt build --debugRunning &quot;build&quot; task[D] Task source: d:\\grunt\\Gruntfile.js[D] 参数：&#123;&quot;requirejs&quot;:&#123;&quot;test&quot;:&#123;&quot;options&quot;:&#123;&quot;baseUrl&quot;:&quot;./&quot;,&quot;paths&quot;:&#123;&quot;$&quot;:&quot;src/zepto&quot;,&quot;_&quot;:&quot;src/underscore&quot;,&quot;B&quot;:&quot;src/backbone&quot;,&quot;Test&quot;:&quot;src/Test01&quot;&#125;,&quot;include&quot;:[&quot;$&quot;,&quot;_&quot;,&quot;B&quot;,&quot;Test&quot;],&quot;out&quot;:&quot;dest/libs.js&quot;&#125;&#125;&#125;&#125;Running &quot;requirejs:test&quot; (requirejs) task[D] Task source: d:\\grunt\\node_modules\\grunt-contrib-requirejs\\tasks\\requirejs.js&gt;&gt; Tracing dependencies for: d:/grunt/dest/libs.js&gt;&gt; Uglifying file: d:/grunt/dest/libs.js&gt;&gt; d:/grunt/dest/libs.js&gt;&gt; ----------------&gt;&gt; d:/grunt/src/zepto.js&gt;&gt; d:/grunt/src/underscore.js&gt;&gt; d:/grunt/src/backbone.js&gt;&gt; d:/grunt/src/Test01.js 效果还是有的，最后我们介绍下requireJS打包模板文件 ##require与模板文件 我们知道，模板文件一般都是html，比如我们这里的demo01.html，对于这个文件我们应该怎么打包呢？其实很简单……需要干两件事情：① 引入require.text② 加入模板文件 1234567891011121314151617181920212223&#123; &quot;requirejs&quot;: &#123; &quot;options&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;$&quot;: &quot;src/zepto&quot;, &quot;_&quot;: &quot;src/underscore&quot;, &quot;B&quot;: &quot;src/backbone&quot;, &quot;test&quot;: &quot;src/test01&quot;, &quot;text&quot;: &quot;src/require.text&quot; &#125;, &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;test&quot;, &quot;text!src/demo01.html&quot; ], &quot;out&quot;: &quot;dest/libs.js&quot; &#125; &#125;&#125; 于是，我们便成功将模板打入了 123456789101112131415161718192021$ grunt build --debugRunning &quot;build&quot; task[D] Task source: d:\\grunt\\Gruntfile.js[D] 参数：&#123;&quot;requirejs&quot;:&#123;&quot;test&quot;:&#123;&quot;options&quot;:&#123;&quot;baseUrl&quot;:&quot;./&quot;,&quot;paths&quot;:&#123;&quot;$&quot;:&quot;src/zepto&quot;,&quot;_&quot;:&quot;src/underscore&quot;,&quot;B&quot;:&quot;src/backbone&quot;,&quot;test&quot;:&quot;src/test01&quot;,&quot;text&quot;:&quot;src/require.text&quot;&#125;,&quot;include&quot;:[&quot;$&quot;,&quot;_&quot;,&quot;B&quot;,&quot;test&quot;,&quot;text!src/demo01.html&quot;],&quot;out&quot;:&quot;dest/libs.js&quot;&#125;&#125;&#125;&#125;Running &quot;requirejs:test&quot; (requirejs) task[D] Task source: d:\\grunt\\node_modules\\grunt-contrib-requirejs\\tasks\\requirejs.js&gt;&gt; Tracing dependencies for: d:/grunt/dest/libs.js&gt;&gt; Uglifying file: d:/grunt/dest/libs.js&gt;&gt; d:/grunt/dest/libs.js&gt;&gt; ----------------&gt;&gt; d:/grunt/src/zepto.js&gt;&gt; d:/grunt/src/underscore.js&gt;&gt; d:/grunt/src/backbone.js&gt;&gt; d:/grunt/src/test01.js&gt;&gt; d:/grunt/src/require.text.js&gt;&gt; text!src/demo01.html 在文件中我们引用方式是： &quot;text!src/demo01.html&quot; =&gt; &apos;具体文件&apos; 过滤关键字 1234567891011121314151617181920212223242526module.exports = function (grunt) &#123; grunt.initConfig(&#123; requirejs: &#123; compile: &#123; &quot;options&quot;: &#123; optimize: &apos;uglify2&apos;, uglify2: &#123; mangle: &#123; except: [&quot;$super&quot;] &#125; &#125;, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;UIAbstractView&quot;: &quot;ui_beta/ui.abstract.view&quot;, &quot;UILayer&quot;: &quot;ui_beta/ui.layer&quot; &#125;, &quot;include&quot;: [ &quot;UIAbstractView&quot; ], &quot;out&quot;: &quot;dest/libs.js&quot; &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); grunt.registerTask(&apos;default&apos;, [&apos;requirejs&apos;]); ##打包样式文件 样式文件的打包方式与js不太一样，这里我们下载css-min插件，并且在package.json中新增依赖项 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;demo&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;, &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.1&quot;, &quot;grunt-contrib-requirejs&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-copy&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;, &quot;grunt-strip&quot;: &quot;~0.2.1&quot;, &quot;grunt-contrib-watch&quot;: &quot;~0.6.0&quot;, &quot;grunt-contrib-cssmin&quot;: &quot;~0.5.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;3.x&quot; &#125;&#125; 1234567891011121314151617module.exports = function (grunt) &#123; grunt.initConfig(&#123; cssmin: &#123; compress: &#123; files: &#123; &apos;dest/car.min.css&apos;: [ &quot;src/car.css&quot;, &quot;src/car01.css&quot; ] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-cssmin&apos;);&#125; 如此一来我们便可以压缩合并CSS文件了： 12345678910111213141516 $ grunt cssmin --debug Running &quot;cssmin:compress&quot; (cssmin) task [D] Task source: d:\\grunt\\node_modules\\grunt-contrib-cssmin\\tasks\\cssmin.js File dest/car.min.css created. ``` ##移动打包文件&gt;其实，grunt本身具有这样的功能，但是我们实际项目重会出现这种可能：&lt;br /&gt;我们核心框架会有一套压缩代码，并且会在对应目录生成文件用于发布，但是这个地方的权限对各个频道团队是不可见的&lt;br /&gt;所以，我们在各个频道的公共文件夹内应该将刚刚的文件给复制过去，这块代码其实很简单，不需要任何新知识都能实现：&lt;br /&gt;我们这里依旧采用昨天的require相关的代码，但是一有个不同的地方就是，我们要同时在D盘的common文件夹中生成该文件&lt;br /&gt;这个代码其实比较简单，这里我们先介绍一个新的插件copy&lt;br /&gt; grunt-contrib-copy 该插件用于复制文件到你想要的文件夹处 grunt.initConfig({ copy: { main: { flatten: true, src: &apos;src/*.js&apos;, dest: &apos;dest/&apos; } } }); 1234567这段代码就会将src中的js文件搞到dest里面，并且新建src文件夹： ``` $ grunt copy Running &quot;copy:main&quot; (copy) task Copied 7 files 若是不想复制文件夹只要文件应该这样干： 12345678910grunt.initConfig(&#123; copy: &#123; main: &#123; flatten: true, // filter: &apos;isFile&apos;, expand: true, src: &apos;src/**.js&apos;, dest: &apos;dest/&apos; &#125;&#125;&#125;); 这块完了，我们就来移动打包文件至D盘了 移动打包文件 这个时候代码这样写就好（也许移动前我们还想将其文件夹里面的东西销毁，暂时不考虑了） 123456789101112131415161718192021222324252627282930313233module.exports = function (grunt) &#123; grunt.initConfig(&#123; copy: &#123; main: &#123; // flatten: true, // expand: true, src: &apos;dest/**.js&apos;, dest: &apos;d:/common/&apos; &#125; &#125; &#125;); grunt.loadNpmTasks(&apos;grunt-contrib-copy&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); grunt.registerTask(&apos;build&apos;, &apos;require demo&apos;, function () &#123; //第一步，读取配置信息 var cfg = grunt.file.readJSON(&apos;cfg.json&apos;); cfg = cfg.requirejs; grunt.config.set(&apos;requirejs&apos;, &#123; test: cfg &#125;); //第二步，设置参数 grunt.log.debug(&apos;参数：&apos; + JSON.stringify(grunt.config())); //第三步跑任务 grunt.task.run([&apos;requirejs&apos;]); &#125;); grunt.registerTask(&apos;default&apos;, &apos;test demo&apos;, [&apos;build&apos;, &apos;copy&apos;]);&#125; 12345678910111213141516Running &quot;build&quot; taskRunning &quot;requirejs:test&quot; (requirejs) task&gt;&gt; Tracing dependencies for: d:/grunt/dest/libs.js&gt;&gt; Uglifying file: d:/grunt/dest/libs.js&gt;&gt; d:/grunt/dest/libs.js&gt;&gt; ----------------&gt;&gt; d:/grunt/src/zepto.js&gt;&gt; d:/grunt/src/underscore.js&gt;&gt; d:/grunt/src/backbone.js&gt;&gt; d:/grunt/src/test01.js&gt;&gt; d:/grunt/src/require.text.js&gt;&gt; text!src/demo01.htmlRunning &quot;copy:main&quot; (copy) taskCopied 8 files 关于移动相关的知识点暂时介绍到这里，我们进入下一话题 ##分支/频道处理 我们在实际项目重会遇到这种情况，我们一个主干分支上可能拉出很多分支完成不同的功能，而各个分支就有那么一点点不同，那么这个时候打包工具该怎么办呢？我们一般是这样处理的：① 首先全局只会有一个打包工具② 其次每一个分支都会有一个gruntCfg.json的配置文件，存储相关的打包信息③ 每次打包时候便把响应的分支打印到各自的dest目录里面为了模拟这一情况我们将grunt打包相关的文件放到D盘的grunt目录里面，并在D盘新建gruntDemo目录然后我们在gruntDemo中建立一个项目，并且为这个项目拉一个分支，比如现在项目是地demo01与demo02现在文件结构如下： 123456789101112131415161718192021222324D:\\GRUNTDEMO├─demo01│ │ gruntCfg.json│ ││ └─src│ backbone.js│ require.js│ require.text.js│ test01.js│ test02.js│ underscore.js│ zepto.js│└─demo02 │ gruntCfg.json │ └─src backbone.js require.js require.text.js test01.js test02.js underscore.js zepto.js 这个时候，要实现功能最好的方法就是写自定义任务了，其它方案不好使，这个时候起配置文件也需要有一定修改，比如其中的路径需要加入参数信息 1234567891011121314151617181920212223&#123; &quot;requirejs&quot;: &#123; &quot;options&quot;: &#123; &quot;baseUrl&quot;: &quot;&lt;%= config.srcDir %&gt;&quot;, &quot;paths&quot;: &#123; &quot;$&quot;: &quot;src/zepto&quot;, &quot;_&quot;: &quot;src/underscore&quot;, &quot;B&quot;: &quot;src/backbone&quot;, &quot;test&quot;: &quot;src/test01&quot;, &quot;text&quot;: &quot;src/require.text&quot; &#125;, &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;test&quot;, &quot;text!src/demo01.html&quot; ], &quot;out&quot;: &quot;&lt;%= config.destDir %&gt;/libs.js&quot; &#125; &#125;&#125; 这个时候initConfig相关信息时候，首先得传入path依赖的文件目录，以及输出的文件目录 1234567891011121314151617181920212223242526272829303132module.exports = function (grunt) &#123; grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); //channel为频道名称，project为项目名称，这里对应gruntDemo，branch为其分支，默认与grunt目录为平行关系，佛则package.json里面应该有配置信息 grunt.registerTask(&apos;build&apos;, &apos;require demo&apos;, function (channel, project, branch) &#123; var path = &apos;../&apos; + channel + &apos;/&apos; + project + branch; grunt.log.debug(&apos;path: &apos; + path); //第一步，读取配置信息 var cfg = grunt.file.readJSON(path + &apos;/gruntCfg.json&apos;); cfg = cfg.requirejs; grunt.config.set(&apos;config&apos;, &#123; srcDir: path, destDir: path + &apos;/dest&apos; &#125;); grunt.config.set(&apos;requirejs&apos;, &#123; main: cfg &#125;); //第二步，设置参数 grunt.log.debug(&apos;param: &apos; + JSON.stringify(grunt.config())); //第三步跑任务 grunt.task.run([&apos;requirejs&apos;]); &#125;); grunt.registerTask(&apos;default&apos;, &apos;test demo&apos;, [&apos;build&apos;, &apos;copy&apos;]);&#125; 于是我们第一步工作成功了： 1234567891011121314151617181920212223$ grunt build:gruntDemo:demo:02 --debugRunning &quot;build:gruntDemo:demo:02&quot; (build) task[D] Task source: d:\\grunt\\Gruntfile.js[D] path: ../gruntDemo/demo02[D] param: &#123;&quot;config&quot;:&#123;&quot;srcDir&quot;:&quot;../gruntDemo/demo02&quot;,&quot;destDir&quot;:&quot;../gruntDemo/demo02/dest&quot;&#125;,&quot;requirejs&quot;:&#123;&quot;main&quot;:&#123;&quot;options&quot;:&#123;&quot;baseUrl&quot;:&quot;../gruntDemo/demo02&quot;,&quot;paths&quot;:&#123;&quot;$&quot;:&quot;src/zepto&quot;,&quot;_&quot;:&quot;src/underscore&quot;,&quot;B&quot;:&quot;src/backbone&quot;,&quot;test&quot;:&quot;src/test01&quot;,&quot;text&quot;:&quot;src/require.text&quot;&#125;,&quot;include&quot;:[&quot;$&quot;,&quot;_&quot;,&quot;B&quot;,&quot;test&quot;,&quot;text!src/demo01.html&quot;],&quot;out&quot;:&quot;../gruntDemo/demo02/dest/libs.js&quot;&#125;&#125;&#125;&#125;Running &quot;requirejs:main&quot; (requirejs) task[D] Task source: d:\\grunt\\node_modules\\grunt-contrib-requirejs\\tasks\\requirejs.js&gt;&gt; Tracing dependencies for: d:/gruntDemo/demo02/dest/libs.js&gt;&gt; Uglifying file: d:/gruntDemo/demo02/dest/libs.js&gt;&gt; d:/gruntDemo/demo02/dest/libs.js&gt;&gt; ----------------&gt;&gt; d:/gruntDemo/demo02/src/zepto.js&gt;&gt; d:/gruntDemo/demo02/src/underscore.js&gt;&gt; d:/gruntDemo/demo02/src/backbone.js&gt;&gt; d:/gruntDemo/demo02/src/test01.js&gt;&gt; d:/gruntDemo/demo02/src/require.text.js&gt;&gt; text!src/demo01.html 如果改变一下任务命令呢： grunt build:gruntDemo:demo:01 --debug 结果证明也是没有问题的，这个地方我就不贴出来了，各位自己去试试，我们分支处理一块暂时到这里 频道处理其实我们这里已经做了，第一个参数是频道，第二个参数是项目，第三个参数为分支，所以频道相关我们暂时就不说了 ##native与HTML5打包 最后让我们来看看如何打包native文件，native文件的打包其实与打包HTML5的方式类似，只不过我们这里需要一点点配置，让一个项目可以打包成不同的效果 仍然以上面demo01为例，他的配置文件可能就需要做一定调整： 123456789101112131415161718192021222324252627282930313233&#123; &quot;requirejs&quot;: &#123; &quot;options&quot;: &#123; &quot;baseUrl&quot;: &quot;&lt;%= config.srcDir %&gt;&quot;, &quot;paths&quot;: &#123; &quot;$&quot;: &quot;src/zepto&quot;, &quot;_&quot;: &quot;src/underscore&quot;, &quot;B&quot;: &quot;src/backbone&quot;, &quot;test&quot;: &quot;src/test01&quot;, &quot;text&quot;: &quot;src/require.text&quot; &#125;, &quot;web&quot;: &#123; &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;test&quot; ], &quot;out&quot;: &quot;&lt;%= config.destDir %&gt;/libs.js&quot; &#125;, &quot;app&quot;: &#123; &quot;include&quot;: [ &quot;$&quot;, &quot;_&quot;, &quot;B&quot;, &quot;test&quot;, &quot;text!src/demo01.html&quot; ], &quot;out&quot;: &quot;&lt;%= config.destDir %&gt;/libs_app.js&quot; &#125; &#125; &#125;&#125; 这里为了表现一点web与native的不同，我特意将web中少包含一个text文件，具体还得各位项目中去实践 如此一来，我们的代码需要做些许调整： 1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = function (grunt) &#123; grunt.loadNpmTasks(&apos;grunt-contrib-requirejs&apos;); //type 打包app包还是web包，channel为频道名称，project为项目名称，这里对应gruntDemo，branch为其分支，默认与grunt目录为平行关系，佛则package.json里面应该有配置信息 grunt.registerTask(&apos;build&apos;, &apos;require demo&apos;, function (type, channel, project, branch) &#123; var path = &apos;../&apos; + channel + &apos;/&apos; + project + branch; grunt.log.debug(&apos;path: &apos; + path); //第一步，读取配置信息 var cfg = grunt.file.readJSON(path + &apos;/gruntCfg.json&apos;); cfg = cfg.requirejs.options; grunt.config.set(&apos;config&apos;, &#123; srcDir: path, destDir: path + &apos;/dest&apos; &#125;); grunt.log.debug(&apos;param: &apos; + JSON.stringify(cfg)); grunt.log.debug(&apos;param: &apos; + cfg[type][&apos;include&apos;]); var taskCfg = &#123;&#125;; taskCfg.options = &#123;&#125;; taskCfg.options.baseUrl = cfg.baseUrl; taskCfg.options.paths = cfg.paths; taskCfg.options[&apos;include&apos;] = cfg[type][&apos;include&apos;]; taskCfg.options.out = cfg[type].out; grunt.config.set(&apos;requirejs&apos;, &#123; main: taskCfg &#125;); //第二步，设置参数 grunt.log.debug(&apos;param: &apos; + JSON.stringify(grunt.config())); //第三步跑任务 grunt.task.run([&apos;requirejs&apos;]); &#125;); grunt.registerTask(&apos;default&apos;, &apos;test demo&apos;, [&apos;build&apos;, &apos;copy&apos;]);&#125; 于是便可以运行了！！！ 1234567891011121314151617181920212223242526272829$ grunt build:app:gruntDemo:demo:01 --debugRunning &quot;build:app:gruntDemo:demo:01&quot; (build) task[D] Task source: d:\\grunt\\Gruntfile.js[D] path: ../gruntDemo/demo01[D] param: &#123;&quot;baseUrl&quot;:&quot;&lt;%= config.srcDir %&gt;&quot;,&quot;paths&quot;:&#123;&quot;$&quot;:&quot;src/zepto&quot;,&quot;_&quot;:&quot;src/underscore&quot;,&quot;B&quot;:&quot;src/backbone&quot;,&quot;test&quot;:&quot;src/test01&quot;,&quot;text&quot;:&quot;src/require.text&quot;&#125;,&quot;web&quot;:&#123;&quot;include&quot;:[&quot;$&quot;,&quot;_&quot;,&quot;B&quot;,&quot;test&quot;],&quot;out&quot;:&quot;&lt;%= config.destDir %&gt;/libs.js&quot;&#125;,&quot;app&quot;:&#123;&quot;include&quot;:[&quot;$&quot;,&quot;_&quot;,&quot;B&quot;,&quot;test&quot;,&quot;text!src/demo01.html&quot;],&quot;out&quot;:&quot;&lt;%= config.destDir %&gt;/libs_app.js&quot;&#125;&#125;[D] param: $,_,B,test,text!src/demo01.html[D] param: &#123;&quot;config&quot;:&#123;&quot;srcDir&quot;:&quot;../gruntDemo/demo01&quot;,&quot;destDir&quot;:&quot;../gruntDemo/demo01/dest&quot;&#125;,&quot;requirejs&quot;:&#123;&quot;main&quot;:&#123;&quot;options&quot;:&#123;&quot;baseUrl&quot;:&quot;../gruntDemo/demo01&quot;,&quot;paths&quot;:&#123;&quot;$&quot;:&quot;src/zepto&quot;,&quot;_&quot;:&quot;src/underscore&quot;,&quot;B&quot;:&quot;src/backbone&quot;,&quot;test&quot;:&quot;src/test01&quot;,&quot;text&quot;:&quot;src/require.text&quot;&#125;,&quot;include&quot;:[&quot;$&quot;,&quot;_&quot;,&quot;B&quot;,&quot;test&quot;,&quot;text!src/demo01.html&quot;], &quot;out&quot;:&quot;../gruntDemo/demo01/dest/libs_app.js&quot;&#125;&#125;&#125;&#125;Running &quot;requirejs:main&quot; (requirejs) task[D] Task source: d:\\grunt\\node_modules\\grunt-contrib-requirejs\\tasks\\requirejs.js&gt;&gt; Tracing dependencies for: d:/gruntDemo/demo01/dest/libs_app.js&gt;&gt; Uglifying file: d:/gruntDemo/demo01/dest/libs_app.js&gt;&gt; d:/gruntDemo/demo01/dest/libs_app.js&gt;&gt; ----------------&gt;&gt; d:/gruntDemo/demo01/src/zepto.js&gt;&gt; d:/gruntDemo/demo01/src/underscore.js&gt;&gt; d:/gruntDemo/demo01/src/backbone.js&gt;&gt; d:/gruntDemo/demo01/src/test01.js&gt;&gt; d:/gruntDemo/demo01/src/require.text.js&gt;&gt; text!src/demo01.html ##结语 我们这个星期花了三天时间一起学习了grunt打包相关的知识点，需要这些知识对您有用，搞这个东西还花费了不少心血呢！！！若是文中有误请一并提出，后续若是这块有所得我们再一起总结吧原来是分成三段，这里将之合一方便各位连贯阅读，篇幅大，记得点赞！","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"grunt","slug":"grunt","permalink":"http://yoursite.com/tags/grunt/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"gulp","slug":"2015-12-17-gulp-使用","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:15.620Z","comments":true,"path":"2015/12/20/2015-12-17-gulp-使用/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-12-17-gulp-使用/","excerpt":"","text":"gulp的用法以及一些插件地址总汇 插件 地址 命令 gulp 地址 npm install gulp del 地址 npm install –save del gulp-autoprefixer 地址 npm install –save-dev gulp-autoprefixer gulp-cache 地址 npm install gulp-cache gulp-clean 地址 npm install –save-dev gulp-clean gulp-cmd-transit 地址 npm install –save-dev gulp-cmd-transit gulp-concat 地址 npm install gulp-concat gulp-imagemin 地址 npm install gulp-imagemin gulp-jshint 地址 npm install gulp-jshint gulp-livereload 地址 npm install gulp-livereload gulp-minify-css 地址 npm install –save-dev gulp-minify-css gulp-notify 地址 npm install gulp-notify gulp-seajs 地址 npm install gulp-seajs gulp-seajs-combo 地址 npm i gulp-seajs-combo gulp-seajs-transport 地址 npm i gulp-seajs-transport gulp-sourcemaps 地址 npm install gulp-sourcemaps gulp-uglify 地址 npm install gulp-uglify gulp 是基于nodejs 的一个自动化任务管理工具。相对于grunt更方便、易用，快捷。 gulp的官网 gulp中文版 gulp优教程 1.安装 2.建 gulpfile.js 文件 3.gulp 的核心方法 3.1src(); 3.2dest(); 3.3 task(); 3.4 watch(); gulp-load-plugins模块 gulp-livereload模块 6.总结 1.安装Gulp需要全局安装，然后再在项目的开发目录中安装为本地模块。先进入项目目录，运行下面的命令。 123npm install -g gulpnpm install --save-dev gulp 除了安装gulp以外，不同的任务还需要安装不同的gulp插件模块。举例来说，下面代码安装了gulp-uglify模块。 1npm install --save-dev gulp-uglify 2.gulpfile.js项目根目录中的gulpfile.js，是Gulp的配置文件。下面就是一个典型的gulpfile.js文件。 12345678var gulp = require(&apos;gulp&apos;);var uglify = require(&apos;gulp-uglify&apos;);gulp.task(&apos;minify&apos;, function () &#123;gulp.src(&apos;js/app.js&apos;).pipe(uglify()) .pipe(gulp.dest(&apos;build&apos;))&#125;); 上面代码中，gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务minify。task方法有两个参数，第一个是任务名，第二个是任务函数。在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。task方法的回调函数使用了两次pipe方法，也就是说做了两种处理。第一种处理是使用gulp-uglify模块，压缩源码；第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件，这里是build.js（代码中省略了后缀名js）。执行minify任务时，就在项目目录中执行下面命令就可以了。 gulp minify 从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。下面是另一个数据流的例子。 1234567gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;js/*.js&apos;) .pipe(jshint()) .pipe(uglify()) .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;build&apos;));&#125;); 上面代码使用pipe命令，分别进行jshint、uglify、concat三步处理。 3.gulp模块的方法3.1 src()gulp模块的src方法，用于产生数据流。它的参数表示所要处理的文件，这些指定的文件会转换成数据流。参数的写法一般有以下几种形式。 js/app.js：指定确切的文件名。 js/.js：某个目录所有后缀名为js的文件。js/**/.js：某个目录及其所有子目录中的所有后缀名为js的文件。!js/app.js：除了js/app.js以外的所有文件。*.+(js | css)：匹配项目根目录下，所有后缀名为js或css的文件。 src方法的参数还可以是一个数组，用来指定多个成员。 gulp.src([&apos;js/**/*.js&apos;, &apos;!js/**/*.min.js&apos;]) 3.2 dest()dest方法将管道的输出写入文件，同时将这些输出继续输出，所以可以依次调用多次dest方法，将输出写入多个目录。如果有目录不存在，将会被新建。 12345gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) .pipe(minify()) .pipe(gulp.dest(&apos;./build/minified_templates&apos;)); dest方法还可以接受第二个参数，表示配置对象。 1234gulp.dest(&apos;build&apos;, &#123; cwd: &apos;./app&apos;, mode: &apos;0644&apos;&#125;) 配置对象有两个字段。cwd字段指定写入路径的基准目录，默认是当前目录；mode字段指定写入文件的权限，默认是0777。 3.3 task()task方法用于定义具体的任务。它的第一个参数是任务名，第二个参数是任务函数。下面是一个非常简单的任务函数。 123gulp.task(&apos;greet&apos;, function () &#123; console.log(&apos;Hello world!&apos;);&#125;); task方法还可以指定按顺序运行的一组任务。 1gulp.task(&apos;build&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;imgs&apos;]); 上面代码先指定build任务，它由css、js、imgs三个任务所组成，task方法会并发执行这三个任务。注意，由于每个任务都是异步调用，所以没有办法保证js任务的开始运行的时间，正是css任务运行结束。如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块。 123gulp.task(&apos;css&apos;, [&apos;greet&apos;], function () &#123; // Deal with CSS here&#125;); 上面代码表明，css任务依赖greet任务，所以css一定会在greet运行完成后再运行。 task方法的回调函数，还可以接受一个函数作为参数，这对执行异步任务非常有用。 123456789// 执行shell命令var exec = require(&apos;child_process&apos;).exec;gulp.task(&apos;jekyll&apos;, function(cb) &#123; // build Jekyll exec(&apos;jekyll build&apos;, function(err) &#123; if (err) return cb(err); // return error cb(); // finished task &#125;);&#125;); 如果一个任务的名字为default，就表明它是“默认任务”，在命令行直接输入gulp命令，就会运行该任务。 1234567gulp.task(&apos;default&apos;, function () &#123; // Your default task&#125;);// 或者gulp.task(&apos;default&apos;, [&apos;styles&apos;, &apos;jshint&apos;, &apos;watch&apos;]); 执行的时候，直接使用gulp，就会运行styles、jshint、watch三个任务。 3.4 watch()watch方法用于指定需要监视的文件。一旦这些文件发生变动，就运行指定任务。 123gulp.task(&apos;watch&apos;, function () &#123; gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);&#125;); 上面代码指定，一旦templates目录中的模板文件发生变化，就运行build任务。 watch方法也可以用回调函数，代替指定的任务。 1234gulp.watch(&apos;templates/*.tmpl.html&apos;, function (event) &#123; console.log(&apos;Event type: &apos; + event.type); console.log(&apos;Event path: &apos; + event.path);&#125;); 另一种写法是watch方法所监控的文件发生变化时（修改、增加、删除文件），会触发change事件。可以对change事件指定回调函数。 12345var watcher = gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);watcher.on(&apos;change&apos;, function (event) &#123; console.log(&apos;Event type: &apos; + event.type); console.log(&apos;Event path: &apos; + event.path);&#125;); 除了change事件，watch方法还可能触发以下事件。 end：回调函数运行完毕时触发。error：发生错误时触发。ready：当开始监听文件时触发。nomatch：没有匹配的监听文件时触发。 watcher对象还包含其他一些方法。 watcher.end()：停止watcher对象，不会再调用任务或回调函数。watcher.files()：返回watcher对象监视的文件。watcher.add(glob)：增加所要监视的文件，它还可以附件第二个参数，表示回调函数。watcher.remove(filepath)：从watcher对象中移走一个监视的文件。 4. gulp-load-plugins模块一般情况下，gulpfile.js中的模块需要一个个加载。 123456789101112var gulp = require(&apos;gulp&apos;), jshint = require(&apos;gulp-jshint&apos;), uglify = require(&apos;gulp-uglify&apos;), concat = require(&apos;gulp-concat&apos;);gulp.task(&apos;js&apos;, function () &#123;return gulp.src(&apos;js/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;)) .pipe(uglify()) .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;build&apos;));&#125;); 上面代码中，除了gulp模块以外，还加载另外三个模块。 这种一一加载的写法，比较麻烦。使用gulp-load-plugins模块，可以加载package.json文件中所有的gulp模块。上面的代码用gulp-load-plugins模块改写，就是下面这样。 12345678910111213var gulp = require(&apos;gulp&apos;), gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;), plugins = gulpLoadPlugins();gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;js/*.js&apos;) .pipe(plugins.jshint()) .pipe(plugins.jshint.reporter(&apos;default&apos;)) .pipe(plugins.uglify()) .pipe(plugins.concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;build&apos;));&#125;); 上面代码假设package.json文件包含以下内容。 12345678&#123; &quot;devDependencies&quot;: &#123; &quot;gulp-concat&quot;: &quot;~2.2.0&quot;, &quot;gulp-uglify&quot;: &quot;~0.2.1&quot;, &quot;gulp-jshint&quot;: &quot;~1.5.1&quot;, &quot;gulp&quot;: &quot;~3.5.6&quot; &#125;&#125; 5.gulp-livereload模块gulp-livereload模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中安装插件，用来配合源码变化。 123456789101112var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;), livereload = require(&apos;gulp-livereload&apos;), watch = require(&apos;gulp-watch&apos;);gulp.task(&apos;less&apos;, function() &#123; gulp.src(&apos;less/*.less&apos;) .pipe(watch()) .pipe(less()) .pipe(gulp.dest(&apos;css&apos;)) .pipe(livereload());&#125;); 上面代码监视less文件，一旦编译完成，就自动刷新浏览器。 6.gulp排除文件的用法12345678910111213141516171819202122var gulp = require(&apos;gulp&apos;);var del = require(&apos;del&apos;);var uglify = require(&apos;gulp-uglify&apos;);var gutil = require(&apos;gulp-util&apos;);var colors = require(&apos;colors/safe&apos;);var gulpif = require(&apos;gulp-if&apos;);gulp.task(&apos;build&apos;, function () &#123; gutil.log(colors.red(&apos;开始压缩js...&apos;)); gulp.src([&apos;*.js&apos;, &apos;!gulpfile.js&apos;]) .pipe(gulpif(&apos;!lang-*.js&apos;, uglify())) .pipe(gulp.dest(&apos;dist&apos;));&#125;);gulp.task(&apos;clean&apos;, function () &#123; gutil.log(colors.red(&apos;开始清空文件&apos;)); del([ &apos;dist&apos; ])&#125;); 本意是想压缩当前目录下的文件夹,但是要排除掉以lang开头的js文件,但是我查看了一下结果,发现lang开头的js文件也被压缩了,这是为啥呢?在gulp.src数组参数用 ！lang-*.js #7.总结 插件 地址 用途 gulp-ruby-sass 地址 基于ruby和sass的Sass文件编译，可将Sass文件为CSS文件 gulp-autoprefixer 地址 Autoprefixer，可以解析CSS文件，并且添加浏览器前缀到CSS规则里 gulp-minify-css 地址 CSS文件压缩工具 gulp-jshint 地址 JSHint，一个JS代码检查工具，可以检测JavaScript中错误和潜在问题 gulp-uglify 地址 JS代码优化工具，可用于压缩和美化（或者叫“丑化”）JavaScript代码 gulp-concat 地址 文件拼接工具，可用于多个CSS文件或多个JS文件的合并 gulp-imagemin 地址 图片压缩工具 gulp-clean 地址 目标目录清理，在用于gulp任务执行前清空目标目录 gulp-cache 地址 资源缓存处理，可用于缓存已压缩过的资源，如：图片 gulp-notify 地址 任务通知工具，可用于某项任务执行完成的在控制台输出通知 gulp-livereload 地址 服务器资源监控，当服务端资源变化时对页面进行刷新。需要要配合浏览器插件使用或在页面这样处理，使用比较复杂，非必要时不推荐使用 gulpfile.js 12345678910111213141516171819var transport = require(&quot;gulp-seajs-transport&quot;);var gulp = require(&quot;gulp&quot;);var concat = require(&apos;gulp-concat&apos;);var uglify = require(&apos;gulp-uglify&apos;);var paths = &#123; scripts: [&apos;./dist/*.js&apos;]&#125;;gulp.task(&apos;scripts&apos;, function() &#123; return gulp.src(paths.scripts) .pipe(transport()) .pipe(concat(&apos;all.min.js&apos;)) .pipe(uglify()) .pipe(sourcemaps.write()) .pipe(gulp.dest(&apos;build/js&apos;));&#125;);gulp.task(&apos;watch&apos;, function() &#123; gulp.watch(paths.scripts, [&apos;scripts&apos;]);&#125;);gulp.task(&apos;default&apos;, [&apos;watch&apos;, &apos;scripts&apos;]); 8.关于访问国外npm慢的解决方法 国内访问外网都很慢，甚至不能访问！大家都懂，都很无奈！安装Node时自带的npm地址默认是：http://registry.npmjs.org ，访问很慢！ 没事，咋们换成国内的！怎么换？ 8.1 通过config命令 1npm config set registry http://registry.cnpmjs.org npm info underscore （如果上面配置正确这个命令会有字符串response） 8.2.命令行指定 1npm --registry http://registry.cnpmjs.org info underscore 8.3.编辑node_modules\\npm.npmrc加入下面内容 1registry = http://registry.cnpmjs.org 如果上面的npm地址不行的话，大家可以试试淘宝的npm，非常稳定: 地址是：https://registry.npm.taobao.org","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"Jekyll目录结构与变量","slug":"2015-10-18-正则","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-21T16:44:40.080Z","comments":true,"path":"2015/12/20/2015-10-18-正则/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-10-18-正则/","excerpt":"","text":"/^\\d{16}|\\d{19}$/ –银行卡– 什么是正则表达式？ /^\\d{16}|\\d{19}$/ –银行卡– (^\\d{15}$)|(^\\d{17}([0-9]|X)$) –身份证– /1[3|5|7|8|][0-9]{9}/ –手机号– /^\\d{4}/ –验证码– **什么是正则表达式？ 这个问题可以参见：“正则表达式30分钟入门教程”，很多编程语言都支持正则表达式，本文仅仅讨论JavaScript中的正则表达式。创建一个正则表达式 第一种方法： var reg = /pattern/; 第二种方法： var reg = new RegExp(&apos;pattern&apos;); **正则表达式的exec方法简介 语法： reg.exec(str); 其中str为要执行正则表达式的目标字符串。例如：** 123456 &lt;script type=&quot;text/javascript&quot;&gt; var reg = /test/; var str = &apos;testString&apos;; var result = reg.exec(str); alert(result); &lt;/script&gt; 将会输出test，因为正则表达式reg会匹配str(‘testString’)中的’test’子字符串，并且将其返回。**我们使用下面的函数来做匹配正则的练习：** 1234function execReg(reg,str)&#123; var result = reg.exec(str); alert(result); &#125; **函数接受一个正则表达式参数reg和一个目标字符串参数str，执行之后会alert出正则表达式与字符串的匹配结果。用这个函数测试上面的例子就是：** 123456789&lt;script type=&quot;text/javascript&quot;&gt; function execReg(reg, str) &#123; var result = reg.exec(str); alert(result); &#125; var reg = /test/; var str = &apos;testString&apos;; execReg(reg, str);&lt;/script&gt; 上面的例子用正则里的test去匹配字符串里的test，实在是很无聊，同样的任务用indexOf方法就可以完成了。用正则，自然是要完成更强大的功能：一片两片三四片，落尽正则全不见 上面的小标题翻译成正则就是{1},{2},{3,4},{1,}。c{n} {1}表示一个的意思。/c{1}/只能匹配一个c。/c{2}/则会匹配两个连续的c。以此类推,/c{n}/则会匹配n个连续的c。看下面的例子：** 123reg = /c&#123;1&#125;/;str = &apos;cainiao&apos;;execReg(reg, str); **返回结果c 123reg = /c&#123;2&#125;/;str = &apos;cainiao&apos;;execReg(reg, str); 返回结果null，表示没有匹配成功。 123reg = /c&#123;2&#125;/;str = &apos;ccVC果冻爽&apos;;execReg(reg, str); 返回结果cc。**c{m,n}c{3,4}的意思是，连续的3个c或者4个c。例如** 123reg = /c&#123;3,4&#125;/;str = &apos;ccVC果冻爽&apos;;execReg(reg, str); 返回结果null，表示没有匹配成功。 123reg = /c&#123;3,4&#125;/;str = &apos;cccTest&apos;;execReg(reg, str); 结果返回ccc。 123reg = /c&#123;3,4&#125;/;str = &apos;ccccTest&apos;;execReg(reg, str); 结果返回cccc，这表明正则会尽量多匹配，可3可4的时候它会选择多匹配一个。 123reg = /c&#123;3,4&#125;/;str = &apos;cccccTest&apos;;execReg(reg, str); 仍然只匹配4个c。**由以上例子可以推断出，c{m,n}表示m个到n个c，且m小于等于n。c{n,}c{1,}表示1个以上的c。例如：** 123reg = /c&#123;1,&#125;/;str = &apos;cainiao&apos;;execReg(reg, str); 结果返回c。 123reg = /c&#123;1,&#125;/;str = &apos;cccccTest&apos;;execReg(reg, str); 返回ccccc，再次说明了正则表达式会尽量多地匹配。 123reg = /c&#123;2,&#125;/;str = &apos;cainiao&apos;;execReg(reg, str); 结果返回null，c{2,}表示2个以上的c，而cainiao中只有1个c。**由以上例子可知，c{n,}表示最少n个c，最多则不限个数。*,+,? *表示0次或者多次，等同于{0,}，即c* 和 c{0,} 是一个意思。+表示一次或者多次，等同于{1,}，即c+ 和 c{1,} 是一个意思。最后，?表示0次或者1次，等同于{0,1}，即c? 和 c{0,1} 是一个意思贪心与非贪心 人都是贪婪的，正则也是如此。我们在例子reg = /c{3,4}/;str=’ccccTest’;的例子中已经看到了，能匹配四个的时候，正则绝对不会去匹配三个。上面所介绍的所有的正则都是这样，只要在合法的情况下，它们会尽量多去匹配字符，这就叫做贪心模式。如果我们希望正则尽量少地匹配字符，那么就可以在表示数字的符号后面加上一个?。组成如下的形式：{n,}?, *?, +?, ??, {m,n}?同样来看一个例子：** 123reg = /c&#123;1,&#125;?/;str = &apos;ccccc&apos;;execReg(reg, str); 返回的结果只有1个c，尽管有5个c可以匹配，但是由于正则表达式是非贪心模式，所以只会匹配一个。**/^开头,结尾$/ **^表示只匹配字符串的开头。看下面的例子： 123reg = /^c/;str = &apos;维生素c&apos;;execReg(reg, str); 结果为null，因为字符串‘维生素c’的开头并不是c，所以匹配失败。 123reg = /^c/;str = &apos;cainiao&apos;;execReg(reg, str); 这次则返回c，匹配成功，因为cainiao恰恰是以c开头的。**与^相反，$则只匹配字符串结尾的字符，同样，看例子：** 123reg = /c$/;str = &apos;cainiao&apos;;execReg(reg, str); 返回null，表示正则表达式没能在字符串的结尾找到c这个字符。 123reg = /c$/;str = &apos;维生素c&apos;;execReg(reg, str); 这次返回的结果是c，表明匹配成功。**点’.’ **‘.’会匹配字符串中除了换行符\\n之外的所有字符，例如 123reg = /./;str = &apos;cainiao&apos;;execReg(reg, str); 结果显示，正则匹配到了字符c。 123reg = /./;str = &apos;blueidea&apos;;execReg(reg, str); 这次是b。 123reg = /.+/;str = &apos;blueidea——经典论坛 好_。&apos;;execReg(reg, str); 结果是“blueidea——经典论坛 好_。“也就是说所有的字符都被匹配掉了，包括一个空格，一个下滑线，和一个破折号。 1234reg = /.+/;reg = /.+/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 同样，直接返回整个字符串——bbs.blueidea.com，可见”.”也匹配”.”本身。 123reg = /^./;str = &apos;\\ncainiao&apos;;execReg(reg, str); 结果是null，终于失败了，正则要求字符串的第一个字符不是换行，但是恰恰字符是以\\n开始的。**二选一，正则表达式中的或，“|“ b|c表示，匹配b或者c。例如：** 123reg = /b|c/;str = &apos;blueidea&apos;;execReg(reg, str); 结果是b。 123reg = /b|c/;str = &apos;cainiao&apos;;execReg(reg, str); 结果是c。 123reg = /^b|c.+/;str = &apos;cainiao&apos;;execReg(reg, str); 匹配掉整个cainiao。 123reg = /^b|c.+/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 结果只有一个b，而不是整个字符串。因为上面正则表达式的意思是，匹配开头的b或者是c.+。**括号 ** 123reg = /^(b|c).+/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 这次的结果是整个串bbs.blueidea.com，加上上面的括号后，这个正则的意思是，如果字符串的开头是b或者c，那么匹配开头的b或者c以及其后的所有的非换行字符。**如果你也实验了的话，会发现返回的结果后面多出来一个“,b“，这是()内的b|c所匹配的内容。我们在正则表达式内括号里写的内容会被认为是子正则表达式，所匹配的结果也会被记录下来供后面使用。我们暂且不去理会这个特性。**字符集合[abc] **[abc]表示a或者b或者c中的任意一个字符。例如： 123reg = /^[abc]/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 返回结果是b。 123reg = /^[abc]/;str = &apos;test&apos;;execReg(reg, str); 这次的结果就是null了。**我们在字字符集合中使用如下的表示方式:[a-z],[A-Z],[0-9]，分别表示小写字母，大写字母，数字。例如：** 123reg = /^[a-zA-Z][a-zA-Z0-9_]+/;str = &apos;test&apos;;execReg(reg, str); 结果是整个test，正则的意思是开头必须是英文字母，后面可以是英文字母或者数字以及下划线。**反字符集合[^abc] **^在正则表达式开始部分的时候表示开头的意思，例如/^c/表示开头是c；但是在字符集和中，它表示的是类似“非“的意思，例如[^abc]就表示不能是a，b或者c中的任何一个。例如： 123reg = /[^abc]/;str = &apos;blueidea&apos;;execReg(reg, str); 返回的结果是l，因为它是第一个非abc的字符（即第一个b没有匹配）。同样： 123reg = /[^abc]/;str = &apos;cainiao&apos;;execReg(reg, str); 则返回i，前两个字符都是[abc]集合中的。**由此我们可知：[^0-9]表示非数字，[^a-z]表示非小写字母，一次类推。**边界与非边界 **\\b表示的边界的意思，也就是说，只有字符串的开头和结尾才算数。例如/\\bc/就表示字符串开始的c或者是结尾的c。看下面的例子： 123reg = /\\bc/;str = &apos;cainiao&apos;;execReg(reg, str); 返回结果c。匹配到了左边界的c字符。 123reg = /\\bc/;str = &apos;维生素c&apos;;execReg(reg, str); 仍然返回c，不过这次返回的是右侧边界的c。 123reg = /\\bc/;str = &apos;bcb&apos;;execReg(reg, str); 这次匹配失败，因为bcb字符串中的c被夹在中间，既不在左边界也不再右边界。**与\\b对应\\B表示非边界。例如：**123reg = /\\Bc/;str = &apos;bcb&apos;;execReg(reg, str); 这次会成功地匹配到bcb中的c，。然而 123reg = /\\Bc/;str = &apos;cainiao&apos;;execReg(reg, str); 则会返回null。因为\\B告诉正则，只匹配非边界的c。**数字与非数字 **\\d表示数字的意思，相反，\\D表示非数字。例如： 123reg = /\\d/;str = &apos;cainiao8&apos;;execReg(reg, str); 返回的匹配结果为8，因为它是第一个数字字符。123reg = /\\D/;str = &apos;cainiao8&apos;;execReg(reg, str); 返回c，第一个非数字字符。**空白 \\f匹配换页符，\\n匹配换行符，\\r匹配回车，\\t匹配制表符，\\v匹配垂直制表符。\\s匹配单个空格，等同于[\\f\\n\\r\\t\\v]。例如：** 123reg = /\\s.+/;str = &apos;This is a test String.&apos;;execReg(reg, str); 返回“is a test String.”，正则的意思是匹配第一个空格以及其后的所有非换行字符。**同样，\\S表示非空格字符。** 123reg = /\\S+/;str = &apos;This is a test String.&apos;;execReg(reg, str); 匹配结果为This，当遇到第一个空格之后，正则就停止匹配了。**单词字符 **\\w表示单词字符，等同于字符集合[a-zA-Z0-9_]。例如： 123reg = /\\w+/;str = &apos;blueidea&apos;;execReg(reg, str); 返回完整的blueidea字符串，因为所有字符都是单词字符。 123reg = /\\w+/;str = &apos;.className&apos;;execReg(reg, str); 结果显示匹配了字符串中的className，只有第一个“.”——唯一的非单词字符没有匹配。 123reg = /\\w+/;str = &apos;中文如何？&apos;;execReg(reg, str); 试图用单词字符去匹配中文自然行不通了，返回null。**\\W表示非单词字符，等效于[^a-zA-Z0-9_]** 123reg = /\\W+/;str = &apos;中文如何？&apos;;execReg(reg, str); 返回完整的字符串，因为，无论是中文和“？”都算作是非单词字符。**反向引用 形式如下：/(子正则表达式)\\1/依旧用例子来说明：**1. 123reg = /\\w/;str = &apos;blueidea&apos;;execReg(reg, str); 返回b。**2.** 123reg = /(\\w)(\\w)/;str = &apos;blueidea&apos;;execReg(reg, str); 返回bl,b,l**bl是整个正则匹配的内容，b是第一个括号里的子正则表达式匹配的内容，l是第二个括号匹配的内容。**3. 123reg = /(\\w)\\1/;str = &apos;blueidea&apos;;execReg(reg, str); 则会返回null。这里的“\\1”就叫做反向引用，它表示的是第一个括号内的字正则表达式匹配的内容。在上面的例子中，第一个括号里的(\\w)匹配了b，因此“\\1”就同样表示b了，在余下的字符串里自然找不到b了。**与第二个例子对比就可以发现，“\\1”是等同于“第1个括号匹配的内容”，而不是“第一个括号的内容”。** 123reg = /(\\w)\\1/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 这个正则则会匹配到bb。**同样，前面有几个子正则表达式我们就可以使用几个反向引用。例如：** 123reg = /(\\w)(\\w)\\2\\1/;str = &apos;woow&apos;;execReg(reg, str); 会匹配成功，因为第一个括号匹配到w，第二个括号匹配到o，而\\2\\1则表示ow，恰好匹配了字符串的最后两个字符。**括号（2） **前面我们曾经讨论过一次括号的问题，见下面这个例子： 123reg = /^(b|c).+/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 这个正则是为了实现只匹配以b或者c开头的字符串，一直匹配到换行字符，但是。上面我们已经看到了，可以使用“\\1”来反向引用这个括号里的子正则表达式所匹配的内容。而且exec方法也会将这个字正则表达式的匹配结果保存到返回的结果中。**不记录子正则表达式的匹配结果 使用形如(?:pattern)的正则就可以避免保存括号内的匹配结果。例如： 123reg = /^(?:b|c).+/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 可以看到返回的结果不再包括那个括号内的字正则表达式多匹配的内容。同理，反向引用也不好使了：** 123reg = /^(b|c)\\1/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 返回bb,b。bb是整个正则表达式匹配的内容，而b是第一个子正则表达式匹配的内容。 123reg = /^(?:b|c)\\1/;str = &apos;bbs.blueidea.com&apos;;execReg(reg, str); 返回null。由于根本就没有记录括号内匹配的内容，自然没有办法反向引用了。**正向预查 形式：(?=pattern)所谓正向预查，意思就是：要匹配的字符串，后面必须紧跟着pattern！**我们知道正则表达式/cainiao/会匹配cainiao。同样，也会匹配cainiao9中的cainiao。但是我们可能希望，cainiao只能匹配cainiao8中的菜鸟。这时候就可以像下面这样写：/cainiao(?=8)/，看两个实例： 123reg = /cainiao(?=8)/;str = &apos;cainiao9&apos;;execReg(reg, str); 返回null。 123reg = /cainiao(?=8)/;str = &apos;cainiao8&apos;;execReg(reg, str); 匹配cainiao。**需要注意的是，括号里的内容并不参与真正的匹配，只是检查一下后面的字符是否符合要求而已，例如上面的正则，返回的是cainiao，而不是cainiao8。**再来看两个例子： 123reg = /blue(?=idea)/;str = &apos;blueidea&apos;;execReg(reg, str); 匹配到blue，而不是blueidea。 123reg = /blue(?=idea)/;str = &apos;bluetooth&apos;;execReg(reg, str); 返回null，因为blue后面不是idea。 123reg = /blue(?=idea)/;str = &apos;bluetoothidea&apos;;execReg(reg, str); 同样返回null。**?! **形式(?!pattern)和?=恰好相反，要求字符串的后面不能紧跟着某个pattern，还拿上面的例子： 123reg = /blue(?!idea)/;str = &apos;blueidea&apos;;execReg(reg, str); 返回null，因为正则要求，blue的后面不能是idea。 123reg = /blue(?!idea)/;str = &apos;bluetooth&apos;;execReg(reg, str); 则成功返回blue。**匹配元字符 首先要搞清楚什么是元字符呢？我们之前用过*,+,?之类的符号，它们在正则表达式中都有一定的特殊含义，类似这些有特殊功能的字符都叫做元字符。例如reg = /c*/; *表示有任意个c，但是如果我们真的想匹配’c’这个字符串的时候怎么办呢？只要将*转义了就可以了，如下： 123reg = /c\\*/;str = &apos;c*&apos;;execReg(reg, str); 返回匹配的字符串：c。*同理，要匹配其他元字符，只要在前面加上一个“\\”就可以了。**正则表达式的修饰符 **全局匹配，修饰符g 形式：/pattern/g例子：reg = /b/g;后面再说这个g的作用。先看后面的两个修饰符。不区分大小写，修饰符i 形式：/pattern/i例子：** 123var reg = /b/;var str = &apos;BBS&apos;;execReg(reg, str); 返回null，因为大小写不符合。 123var reg = /b/i;var str = &apos;BBS&apos;;execReg(reg, str); 匹配到B，这个就是i修饰符的作用了。**行首行尾，修饰符m 形式：/pattern/mm修饰符的作用是修改^和$在正则表达式中的作用，让它们分别表示行首和行尾。例如：** 123var reg = /^b/;var str = &apos;test\\nbbs&apos;;execReg(reg, str); 匹配失败，因为字符串的开头没有b字符。但是加上m修饰符之后： 123var reg = /^b/m;var str = &apos;test\\nbbs&apos;;execReg(reg, str); 匹配到b，因为加了m修饰符之后，^已经表示行首，由于bbs在字符串第二行的行首，所以可以成功地匹配。**exec方法详解 **exec方法的返回值 exec方法返回的其实并不是匹配结果字符串，而是一个对象，简单地修改一下execReg函数，来做一个实验就可以印证这一点： 123456function execReg(reg,str)&#123; var result = reg.exec(str); alert(typeof result); &#125; var reg = /b/; var str=&apos;bbs.bblueidea.com&apos;; execReg(reg,str); 结果显示result的类型是object。而且是一个类似数组的对象。使用for in可以知道它的属性: index input 0。其中index是表示匹配在原字符串中的索引；而input则是表示输入的字符串；至于0则是表示只有一个匹配结果，可以用下标0来引用这个匹配结果，这个数量可能改变。我们可以通过返回值的length属性来得知匹配结果的总数量。根据以上对返回值的分析，修改execReg函数如下： 1234567function execReg(reg, str) &#123; var result = reg.exec(str); document.write(&apos;index:&apos; + result.index + &apos;&lt;br /&gt;&apos; + &apos;input:&apos; + result.input + &apos;&lt;br /&gt;&apos;); for (i = 0; i &lt; result.length; i++) &#123; document.write(&apos;result[&apos; + i + &apos;]:&apos; + result[i] + &apos;&lt;br /&gt;&apos;) &#125;&#125; **马上来实验一下： 123var reg = /\\w/;var str = &apos;bbs.bblueidea.com&apos;;execReg(reg, str); 结果如下：**index:0input:bbs.bblueidea.comresult[0]:b输入字符串为bbs.bblueidea.com；匹配的b在原字符串的索引是0。**正则的匹配结果为一个，b； 123var reg = /(\\w)(\\w)(.+)/;var str = &apos;bbs.bblueidea.com&apos;;execReg(reg, str); 结果为：**index:0input:bbs.bblueidea.comresult[0]:bbs.bblueidea.comresult[1]:bresult[2]:bresult[3]:s.bblueidea.com由上面两个例子可见，返回对象[0]就是整个正则表达式所匹配的内容。后续的元素则是各个子正则表达式的匹配内容。**exec方法对正则表达式的更新 **exec方法在返回结果对象的同时，还可能会更新原来的正则表达式，这就要看正则表达式是否设置了g修饰符。先来看两个例子吧： 1234var reg = /b/;var str = &apos;bbs.blueidea.com&apos;;execReg(reg, str);execReg(reg, str); 结果如下：**index:0input:bbs.blueidea.comresult[0]:bindex:0input:bbs.blueidea.comresult[0]:b也就是说，两次匹配的结果完全一样，从索引可以看出来，匹配的都是字符串首的b字符。**下面看看设置了g的正则表达式表现如何： 1234var reg = /b/g;var str = &apos;bbs.blueidea.com&apos;;execReg(reg, str);execReg(reg, str); 结果如下：**index:0input:bbs.blueidea.comresult[0]:bindex:1input:bbs.blueidea.comresult[0]:b可以看得出来，第二次匹配的是字符串的字符串的第二个b。这也就是g修饰符的作用了，下面来看exec是如何区别对待g和非g正则表达式的。如果正则表达式没有设置g，那么exec方法不会对正则表达式有任何的影响，如果设置了g，那么exec执行之后会更新正则表达式的lastIndex属性，表示本次匹配后，所匹配字符串的下一个字符的索引，下一次再用这个正则表达式匹配字符串的时候就会从上次的lastIndex属性开始匹配，也就是上面两个例子结果不同的原因了。test方法 **test方法仅仅检查是否能够匹配str，并且返回布尔值以表示是否成功。同样建立一个简单的测试函数： 123 function testReg(reg, str) &#123; alert(reg.test(str));&#125; 实例1 123var reg = /b/;var str = &apos;bbs.blueidea.com&apos;;testReg(reg, str); 成功，输出true。**实例2** 123var reg = /9/;var str = &apos;bbs.blueidea.com&apos;;testReg(reg, str); 失败，返回false。**使用字符串的方法执行正则表达式 **match方法 形式：str.match(reg);与正则表达式的exec方法类似，该方法同样返回一个类似数组的对象，也有input和index属性。我们定义如下一个函数用来测试：**1234567891011function matchReg(reg, str) &#123; var result = str.match(reg); if (result) &#123; document.write(&apos;index:&apos; + result.index + &apos;&lt;br /&gt;&apos; + &apos;input:&apos; + result.input + &apos;&lt;br /&gt;&apos;); for (i = 0; i &lt; result.length; i++) &#123; document.write(&apos;result[&apos; + i + &apos;]:&apos; + result[i] + &apos;&lt;br /&gt;&apos;) &#125; &#125; else &#123; alert(&apos;null：匹配失败！&apos;) &#125;&#125; 例如： 123var reg = /b/;var str = &apos;bbs.blueidea.com&apos;;matchReg(reg, str); 结果如下：index:0input:bbs.blueidea.comresult[0]:b可见，和exec的结果一样。但是如果正则表达式设置了g修饰符，exec和match的行为可就不一样了，见下例：index:undefinedinput:undefinedresult[0]:bresult[1]:bresult[2]:b设置了g修饰符的正则表达式在完成一次成功匹配后不会停止，而是继续找到所有可以匹配到的字符。返回的结果包括了三个b。不过没有提供input和index这些信息。replace方法 形式：str. replace (reg,’new str’);它的作用是将str字符串中匹配reg的部分用’’new str”部分代码，值得注意的是原字符串并不会被修改，而是作为返回值被返回。例子：** 1234var reg = /b/;var str = &apos;bbs.blueidea.com&apos;;var newStr = str.replace(reg, &apos;c&apos;);document.write(newStr); 结果为cbs.blueidea.com，只有第一个b被替换为c。 1234var reg = /b/g;var str = &apos;bbs.blueidea.com&apos;;var newStr = str.replace(reg, &apos;c&apos;);document.write(newStr); 输出ccs.clueidea.com**由于，设置了g修饰符，所以会替换掉所有的b。** 1234var reg = /\\w+/g; var str = &apos;bbs.blueidea.com&apos;; var newStr = str.replace(reg, &apos;word&apos;); document.write(newStr); 输出：**word.word.word。**在replace函数中使用$引用子正则表达式匹配内容 就像在正则里我们可以使用\\1来引用第一个子正则表达式所匹配的内容一样，我们在replace函数的替换字符里也可以使用$1来引用相同的内容。还是来看一个例子吧：** 1234var reg = /(\\w+).(\\w+).(\\w+)/;var str = &apos;bbs.blueidea.com&apos;;var newStr = str.replace(reg, &apos;$1.$1.$1&apos;);document.write(newStr); 输出的结果为：**bbs.bbs.bbs首先，我们知道第一个子正则表达式匹配到了bbs，那么$1也就代表bbs了。其后我们把替换字符串设置为’$1.$1.$1’,其实也就是“bbs.bbs.bbs”。同理，$2就是blueidea，$3就是com。在来看一个例子，颠倒空格前后两个单词的顺序。** 1234var reg = /(\\w+)\\s(\\w+)/;var str = &apos;cainiao gaoshou&apos;;var newStr = str.replace(reg, &apos;$2 $1&apos;);document.write(newStr); 结果为：gaoshou cainiao，也就是空格前后的单词被调换顺序了。**由于在替换文本里$有了特殊的含义，所以我们如果想要是用$这个字符的话，需要写成$$，例如：**1234var reg = /(\\w+)\\s(\\w+)/;var str = &apos;cainiao gaoshou&apos;;var newStr = str.replace(reg, &apos;$ $&apos;);document.write(newStr); 结果为：$ $。**search方法和split方法 同样，字符串的search方法和split方法中也可以使用正则表达式，形式如下：str.search(reg);**search返回正则表达式第一次匹配的位置。例子：1234var reg = /idea/;var str = &apos;blueidea&apos;;var pos = str.search(reg);document.write(pos); 1234var reg = /\\W/;var str = &apos;bbs.blueidea.com&apos;;var pos = str.search(reg);document.write(pos); 结果为3，也就是那个点“.”的位置。str.split(reg,’seprator’);split返回分割后的数组，例如：1234var reg = /\\W/;var str = &apos;bbs.blueidea.com&apos;;var arr = str.split(reg);document.write(arr); 结果为：bbs,blueidea,com，可见数组被非单词字符分为了有三个元素的数组。12345var reg = /\\W/;var str = &apos;http://www.baidu.com/&apos;;var arr = str.split(reg);document.write(arr.length + &apos;&lt;br /&gt;&apos;);document.write(arr); 结果为：**7http,,,www,baidu,com,可见字符串被分为了有7个元素的数组，其中包括了三个为空字符串的元素。**","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"胡言乱语","slug":"2015-10-19-乱语","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:09:45.629Z","comments":true,"path":"2015/12/20/2015-10-19-乱语/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-10-19-乱语/","excerpt":"","text":"没事发发骚 何以飘零去 何以少团栾 何以别离久 何以不得安 指云问天道 琴鸣血斑斓 ——记《古剑奇谭》 by wushuang","categories":[{"name":"奇谭","slug":"奇谭","permalink":"http://yoursite.com/categories/奇谭/"}],"tags":[{"name":"乱语","slug":"乱语","permalink":"http://yoursite.com/tags/乱语/"}],"keywords":[{"name":"奇谭","slug":"奇谭","permalink":"http://yoursite.com/categories/奇谭/"}]},{"title":"web-mobile","slug":"2015-10-19-web-mobile开发总汇","date":"2015-12-19T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/20/2015-10-19-web-mobile开发总汇/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-10-19-web-mobile开发总汇/","excerpt":"摘自- 移动平台WEB前端开发技巧汇总 －－－－－－－－－－－华丽的分割线－－－－－－－－－－－－－","text":"摘自- 移动平台WEB前端开发技巧汇总 －－－－－－－－－－－华丽的分割线－－－－－－－－－－－－－ 原名《移动平台3G手机网站前端开发布局技巧汇总》，由武方博整理的，让我们了解下移动设备上的WEB站点开发的基础知识，多些时间和精力去优化其他细节，我这里对原文的标签格式做了细微的调整，阅读查看起来明晰些，原文如下： 您或许正在或准备参与一个WepApp项目，您或许正在Google搜索mobile development相关的文章，您或许是一名专业的WEB前端工程师，您或许想学习Mobile前端开发方面的技术，如果您被我说中了，呵呵那么这篇文章将为您带来意想不到的惊喜！当您看到这篇文章时，哥已经默认认为您是一名资深的WEB前端工程师，如果您不是，可能您会遇见许多不理解或听不懂的专业术语或前端技术（包括WEB、Mobile）。但是这没有关系，给自己一点信心吧，用心的阅读下去…… 自Iphone和Android这两个牛逼的手机操作系统发布以来，在互联网界从此就多了一个新的名词-WebApp(意为基于WEB形式的应用程序，运行在高端的移动终端设备)。 开发者们都知道在高端智能手机系统中有两种应用程序：一种是基于本地（操作系统）运行的APP；一种是基于高端机的浏览器运行的WebApp，本文将主要讲解后者。 WebApp与Native App有何区别呢？Native App： 开发成本非常大一般使用的开发语言为JAVA、C++、Objective-C更新体验较差、同时也比较麻烦每一次发布新的版本，都需要做版本打包，且需要用户手动更新（有些应用程序即使不需要用户手动更新，但是也需要有一个恶心的提示）。非常酷因为native app可以调用IOS中的UI控件以UI方法，它可以实现WebApp无法实现的一些非常酷的交互效果Native app是被Apple认可的Native app可以被Apple认可为一款可信任的独立软件，可以放在Apple Stroe出售，但是Web app却不行。Web App： 开发成本较低使用web开发技术就可以轻松的完成web app的开发升级较简单升级不需要通知用户，在服务端更新文件即可，用户完全没有感觉维护比较轻松和一般的web一样，维护比较简单，它其实就是一个站点 Webapp说白了就是一个针对Iphone、Android优化后的web站点，它使用的技术无非就是HTML或HTML5、CSS3、JavaScript，服务端技术JAVA、PHP、ASP。 当然，因为这些高端智能手机（Iphone、Android）的内置浏览器都是基于webkit内核的，所以在开发WEBAPP时，多数都是使用HTML5和CSS3技术做UI布局。当使用HTML5和CSS3l做UI时，若还是遵循着一般web开发中使用HTML4和CSS2那样的开发方式的话，这也就失去了WEBAPP的本质意义了，且有些效果也无法实现的，所以在此又回到了我们的主题–webapp的布局方式和技术。 在此说明一下，在此所说的移动平台前端开发是指针对高端智能手机（如Iphone、Android）做站点适配也就是WebApp，并非是针对普通手机开发Wap 2.0，所以在阅读本篇文章以前，你需要对webkit内核的浏览器有一定的了解，你需要对HTML5和CSS3有一定的了解。如果你已经对此有所了解，那现在就开始往下阅读吧…… ##1、首先我们来看看webkit内核中的一些私有的meta标签，这些meta标签在开发webapp时起到非常重要的作用1234&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot; /&gt;&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot; /&gt;&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot; /&gt;&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot; /&gt; 第一个meta标签表示：强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览； 第二个meta标签是iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览； 第三个meta标签也是iphone的私有标签，它指定的iphone中safari顶端的状态条的样式； 第四个meta标签表示：告诉设备忽略将页面中的数字识别为电话号码； ##2、HTML5标签的使用 在开始编写webapp时，哥建议前端工程师使用HTML5，而放弃HTML4，因为HTML5可以实现一些HTML4中无法实现的丰富的WEB应用程序的体验，可以减少开发者很多的工作量，当然了你决定使用HTML5前，一定要对此非常熟悉，要知道HTML5的新标签的作用。比如定义一块内容或文章区域可使用section标签，定义导航条或选项卡可以直接使用nav标签等等。 ##3、放弃CSS float属性 在项目开发过程中可以会遇到内容排列排列显示的布局，假如你遇见这样的视觉稿，哥建议你放弃 float，可以直接使用1display:block; ##4、利用CSS3边框背景属性 这个按钮有圆角效果，有内发光效果还有高光效果，这样的按钮使用CSS3写是无法写出来的，当然圆角可以使用CSS3来写，但高光和内发光却无法使用CSS3编写，这个时候你不妨使用1-webkit-border-image 来定义这个按钮的样式。1-webkit-border-image 就个很复杂的样式属性。 ##5、块级化a标签 请保证将每条数据都放在一个a标签中，为何这样做？因为在触控手机上，为提升用户体验，尽可能的保证用户的可点击区域较大。 ##6、自适应布局模式 在编写CSS时，我不建议前端工程师把容器（不管是外层容器还是内层）的宽度定死。为达到适配各种手持设备，我建议前端工程师使用自适应布局模式（支付宝采用了自适应布局模式），因为这样做可以让你的页面在ipad、itouch、ipod、iphone、android、web safarik、chrome都能够正常的显示，你无需再次考虑设备的分辨率。 ##7、学会使用webkit-box 上一节，我们说过自适应布局模式，有些同学可能会问：如何在移动设备上做到完全自适应呢？很感谢webkit为display属性提供了一个 1webkit-box 的值，它可以帮助前端工程师做到盒子模型灵活控制。 ##8、如何去除Android平台中对邮箱地址的识别 看过iOS webapp API的同学都知道iOS提供了一个meta标签:用于禁用iOS对页面中电话号码的自动识别。在iOS中是不自动识别邮件地址的，但在Android平台，它会自动检测邮件地址，当用户touch到这个邮件地址时，Android会弹出一个框提示用户发送邮件，如果你不想Android自动识别页面中的邮件地址，你不妨加上这样一句meta标签在head中1&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt; ##9、如何去除iOS和Android中的输入URL的控件条 你的老板或者PD或者交互设计师可能会要求你：能否让我们的webapp更加像nativeapp，我不想让用户看见那个输入url的控件条？答案是可以做到的。我们可以利用一句简单的javascript代码来实现这个效果 1setTimeout(scrollTo,0,0,0); 请注意，这句代码必须放在1window.onload 里才能够正常的工作，而且你的当前文档的内容高度必须是高于窗口的高度时，这句代码才能有效的执行。 ##10、如何禁止用户旋转设备 我曾经也想禁止用户旋转设备，也想实现像某些客户端那样：只能在肖像模式或景观模式下才能正常运行。但现在我可以很负责任的告诉你：别想了!在移动版的webkit中做不到！ 至少Apple webapp API已经说到了：我们为了让用户在safari中正常的浏览网页，我们必须保证用户的设备处于任何一个方位时，safari都能够正常的显示网页内容（也就是自适应），所以我们禁止开发者阻止浏览器的1orientationchange 事件，看来苹果公司的出发点是正确的，苹果确实不是一般的苹果。 iOS已经禁止开发者阻止1orientationchange 事件，那Android呢？对不起，我没有找到任何资料说Android禁止开发者阻止浏览器1orientationchange 事件，但是在Android平台，确实也是阻止不了的。 ##11、如何检测用户是通过主屏启动你的webapp 看过Apple webapp API的同学都知道iOS为safari提供了一个将当前页面添加主屏的功能，按下iphone ipod ipod touch底部工具中的小加号，或者ipad顶部左侧的小加号，就可以将当前的页面添加到设备的主屏，在设备的主屏会自动增加一个当前页面的启动图标，点击该启动图标就可以快速、便捷的启动你的webapp。 从主屏启动的webapp和浏览器访问你的webapp最大的区别是它清除了浏览器上方和下方的工具条，这样你的webapp就更加像是nativeapp了，还有一个区别是window对像中的navigator子对象的一个 standalone属性。 iOS中浏览器直接访问站点时， 1navigator.standalone 为false,从主屏启动webapp时， 1navigator.standalone为true ，我们可以通过navigator.standalone这个属性获知用户当前是否是从主屏访问我们的webapp的。在Android中从来没有添加到主屏这回事！ ##12、如何关闭iOS中键盘自动大写 我们知道在iOS中，当虚拟键盘弹出时，默认情况下键盘是开启首字母大写的功能的，根据某些业务场景，可能我们需要关闭这个功能，移动版本webkit为input元素提供了 1autocapitalize ，通过指定 1autocapitalize=&quot;off&quot; 来关闭键盘默认首字母大写。 ##13、iOS中如何彻底禁止用户在新窗口打开页面有时我们可能需要禁止用户在新窗口打开页面，我们可以使用a标签的 1target=&quot;_self&quot; 来指定用户在新窗口打开，或者1target 属性保持空，但是你会发现iOS的用户在这个链接的上方长按3秒钟后，iOS会弹出一个列表按钮，用户通过这些按钮仍然可以在新窗口打开页面，这样的话，开发者指定的target属性就失效了，但是可以通过指定当前元素的 1-webkit-touch-callout 样式属性为none来禁止iOS弹出这些按钮。这个技巧仅适用iOS对于Android平台则无效。 ##14、iOS中如何禁止用户保存图片＼复制图片我们在第13条技巧中提到元素的 1-webkit-touch-callout 属性，同样为一个img标签指定 1-webkit-touch-callout:none ，这样用户就无法保存＼复制你的图片了。 ##15、iOS中如何禁止用户选中文字我们通过指定文字标签的1-webkit-user-select:none 便可以禁止iOS用户选中文字。 ##16、iOS中如何获取滚动条的值桌面浏览器中想要获取滚动条的值是通过 1document.scrollTop 和 1document.scrollLeft 得到的，但在iOS中你会发现这两个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？通过window.scrollY和window.scrollX我们可以得到当前窗口的y轴和x轴滚动条的值。 ##17、如何解决盒子边框溢出当你指定了一个块级元素时，并且为其定义了边框，设置了其宽度为100％。在移动设备开发过程中我们通常会对文本框定义为宽度100％，将其定义为块级元素以实现全屏自适应的样式，但此时你会发现，该元素的边框(左右)各1个像素会溢了文档，导致出现横向滚动条，为解决这一问题，我们可以为其添加一个特殊的样式1-webkit-box-sizing:border-box; 用来指定该盒子的大小包括边框的宽度。 ##18、如何解决Android 2.0以下平台中圆角的问题 如果大家够细心的话，在做wap站点开发时，大家应该会发现android 2.0以下的平台中问题特别的多，比如说边框圆角这个问题吧。 在对一个元素定义圆角时，为完全兼容android 2.0以下的平台，我们必须要按照以下技巧来定义边框圆角： -webkit 这个前缀必须要加上（在iOS中，你可以不加，但android中一定要加）； 如果对针对边框做样式定义，比如1border:1px solid #000; 那么1-webkit-border-radius 这属性必须要出现在 border 属性后。 假如我们有这样的视觉元素，左上角和右上角是圆角时，我们必须要先定义全局的(4个角的圆角值) 1-webkit-border-radius:5px; 然后再依次的覆盖左下角和右下角， 1-webkit-border-bottom-left-radius:0;-webkit-border-bottom-right-border:0; 否则在android 2.0以下的平台中将全部显示直角，还有记住！ -webkit 这个前缀一定要加上！ ##19、如何解决android平台中页面无法自适应虽然你的html和css都是完全自适应的，但有一天如果你发现你的页面在android中显示的并不是自适应的时候，首先请你确认你的head标签中是否包含以下meta标签： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0;&quot; /&gt; 如果有的话，那请你再仔细的看清楚有没有这个属性的值1width=device-width ，如果没有请立即加上吧！ ##20、如何解决iOS 4.3版本中safari对页面中5位数字的自动识别和自动添加样式 新的iOS系统也就是4.3版本，升级后对safari造成了一个bug：即使你添加了如下的meta标签，safari仍然会对页面中的5位连续的数字进行自动识别，并且将其重新渲染样式，也就是说你的css对该标签是无效的。 1&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no&quot; /&gt; 我们可以用一个比较龌龊的办法来解决。比如说支付宝wap站点中显示金额的标签，我们都做了如下改写： 1&lt;button class=&quot;t-balance&quot; style=&quot;background:none;padding:0;border:0;&quot;&gt;95009.00&lt;/button&gt;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"js计算闰年平年","slug":"2015-11-20-用js判断闰年平年","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:38.605Z","comments":true,"path":"2015/12/20/2015-11-20-用js判断闰年平年/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-11-20-用js判断闰年平年/","excerpt":"","text":"js计算闰年平年 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;JavaScript&quot;&gt;var isSmoothYear = function(year)&#123; return (new Date(year , 2 , 0).getDate() == 29?&quot;闰年&quot;:&quot;平年&quot;);&#125;console.log(&quot;2015年 是润年吗? \\t&quot; + isSmoothYear(2015));console.log(&quot;2016年 是润年吗? \\t&quot; + isSmoothYear(2016));console.log(&quot;2017年 是润年吗? \\t&quot; + isSmoothYear(2017));console.log(&quot;2018年 是润年吗? \\t&quot; + isSmoothYear(2018));console.log(&quot;2019年 是润年吗? \\t&quot; + isSmoothYear(2019));console.log(&quot;2020年 是润年吗? \\t&quot; + isSmoothYear(2020));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"异步","slug":"2015-11-18-async[nodejs 异步流程控制]","date":"2015-12-19T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/20/2015-11-18-async[nodejs 异步流程控制]/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-11-18-async[nodejs 异步流程控制]/","excerpt":"出处 目录： Async介绍 Async安装…….项目地址.","text":"出处 目录： Async介绍 Async安装…….项目地址. 出处 目录： Async介绍 Async安装 Async函数介绍 async_demo使用介绍 场景：对数据库的连续操作 async_demo我的分支 1. Async介绍 Async是一个流程控制工具包，提供了直接而强大的异步功能。基于Javascript为Node.js设计，同时也可以直接在浏览器中使用。Async提供了大约20个函数，包括常用的 map, reduce, filter, forEach 等，异步流程控制模式包括，串行(series)，并行(parallel)，瀑布(waterfall)等。 项目地址. 2. Async安装 我们做实验时，安装async有两个方式: 独立安装async 下载async demo代码安装 我建议大家用第二种方式安装，这样子实例的代码就都有了。 独立安装async(1) 12345~ D:\\workspace\\javascript&gt;mkdir nodejs-async &amp;&amp; cd nodejs-async~ D:\\workspace\\javascript\\nodejs-async&gt;npm install asyncnpm http GET https://registry.npmjs.org/asyncnpm http 304 https://registry.npmjs.org/asyncasync@0.2.9 node_modules\\async 打开网页,参照示例学习 下载async demo代码安装(2) 123456789~ D:\\workspace\\javascript&gt;git clone git@github.com:bsspirit/async_demo.git nodejs-async~ D:\\workspace\\javascript&gt;cd nodejs-async~ D:\\workspace\\javascript\\nodejs-async&gt;npm installnpm http GET https://registry.npmjs.org/momentnpm http GET https://registry.npmjs.org/asyncnpm http 304 https://registry.npmjs.org/momentnpm http 304 https://registry.npmjs.org/asyncasync@0.2.9 node_modules\\asyncmoment@2.1.0 node_modules\\moment 这套demo示例，比较全面的介绍了async的使用，有中文注释。 感谢github社区原创作者freewind，代码更新的贡献者alsotang。当然，我的分支中也修改了一部分代码。在本文最后，我会写到changelog中！* 3. Async函数介绍基于async的0.2.9版本。 async主要实现了三个部分的流程控制功能： * 集合: Collections 流程控制: Control Flow 工具类: Utils 1). 集合: Collections * each: 如果想对同一个集合中的所有元素都执行同一个异步操作。 map: 对集合中的每一个元素，执行某个异步操作，得到结果。所有的结果将汇总到最终的callback里。与each的区别是，each只关心操作不管最后的值，而map关心的最后产生的值。 filter: 使用异步操作对集合中的元素进行筛选, 需要注意的是，iterator的callback只有一个参数，只能接收true或false。 reject: reject跟filter正好相反，当测试为true时则抛弃 reduce: 可以让我们给定一个初始值，用它与集合中的每一个元素做运算，最后得到一个值。reduce从左向右来遍历元素，如果想从右向左，可使用reduceRight。 detect: 用于取得集合中满足条件的第一个元素。 sortBy: 对集合内的元素进行排序，依据每个元素进行某异步操作后产生的值，从小到大排序。 some: 当集合中是否有至少一个元素满足条件时，最终callback得到的值为true，否则为false. every: 如果集合里每一个元素都满足条件，则传给最终回调的result为true，否则为false concat: 将多个异步操作的结果合并为一个数组。 2). 流程控制: Control Flow * series: 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。 parallel: 并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。 whilst: 相当于while，但其中的异步调用将在完成后才会进行下一次循环。 doWhilst: 相当于do…while, doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。 until: until与whilst正好相反，当test为false时循环，与true时跳出。其它特性一致。 doUntil: doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。 forever: 无论条件循环执行，如果不出错，callback永远不被执行。 waterfall: 按顺序依次执行一组函数。每个函数产生的值，都将传给下一个。 compose: 创建一个包括一组异步函数的函数集合，每个函数会消费上一次函数的返回值。把f(),g(),h()异步函数，组合成f(g(h()))的形式，通过callback得到返回值。 applyEach: 实现给一数组中每个函数传相同参数，通过callback返回。如果只传第一个参数，将返回一个函数对象，我可以传参调用。 queue: 是一个串行的消息队列，通过限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。 cargo: 一个串行的消息队列，类似于queue，通过限制了worker数量，不再一次性全部执行。不同之处在于，cargo每次会加载满额的任务做为任务单元，只有任务单元中全部执行完成后，才会加载新的任务单元。 auto: 用来处理有依赖关系的多个任务的执行。 iterator: 将一组函数包装成为一个iterator，初次调用此iterator时，会执行定义中的第一个函数并返回第二个函数以供调用。 apply: 可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。 nextTick: 与nodejs的nextTick一样，再最后调用函数。 times: 异步运行,times可以指定调用几次，并把结果合并到数组中返回 timesSeries: 与time类似，唯一不同的是同步执行 3). 工具类: Utils * memoize: 让某一个函数在内存中缓存它的计算结果。对于相同的参数，只计算一次，下次就直接拿到之前算好的结果。 unmemoize: 让已经被缓存的函数，返回不缓存的函数引用。 log: 执行某异步函数，并记录它的返回值，日志输出。 dir: 与log类似，不同之处在于，会调用浏览器的console.dir()函数，显示为DOM视图。 noConflict: 如果之前已经在全局域中定义了async变量，当导入本async.js时，会先把之前的async变量保存起来，然后覆盖它。仅仅用于浏览器端，在nodejs中没用，这里无法演示。 4. async_demo使用介绍详细使用请参考github源代码： 每个函数的用法，有非常详细的实例！！ * 5. 场景：对数据库的连续操作 这个场景进背景情况，请参考文章：用Nodejs连接MySQL 原场景中，对数据串行操作，增删改查(CRUD)，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var mysql = require(&apos;mysql&apos;);var conn = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;nodejs&apos;, password: &apos;nodejs&apos;, database: &apos;nodejs&apos;, port: 3306&#125;);conn.connect();var insertSQL = &apos;insert into t_user(name) values(&quot;conan&quot;),(&quot;fens.me&quot;)&apos;;var selectSQL = &apos;select * from t_user limit 10&apos;;var deleteSQL = &apos;delete from t_user&apos;;var updateSQL = &apos;update t_user set name=&quot;conan update&quot; where name=&quot;conan&quot;&apos;;//deleteconn.query(deleteSQL, function (err0, res0) &#123; if (err0) console.log(err0); console.log(&quot;DELETE Return ==&gt; &quot;); console.log(res0); //insert conn.query(insertSQL, function (err1, res1) &#123; if (err1) console.log(err1); console.log(&quot;INSERT Return ==&gt; &quot;); console.log(res1); //query conn.query(selectSQL, function (err2, rows) &#123; if (err2) console.log(err2); console.log(&quot;SELECT ==&gt; &quot;); for (var i in rows) &#123; console.log(rows[i]); &#125; //update conn.query(updateSQL, function (err3, res3) &#123; if (err3) console.log(err3); console.log(&quot;UPDATE Return ==&gt; &quot;); console.log(res3); //query conn.query(selectSQL, function (err4, rows2) &#123; if (err4) console.log(err4); console.log(&quot;SELECT ==&gt; &quot;); for (var i in rows2) &#123; console.log(rows2[i]); &#125; &#125;); &#125;); &#125;); &#125;);&#125;);//conn.end(); 为了实现了串行操作，所有的调用都是在callback中实现的，5层嵌套结构。这种代码已经变得不可以维护了。所以，需要用async库，对上面的代码结构进行重写！修改后的代码 12345678910111213141516171819202122232425262728var mysql = require(&apos;mysql&apos;);var async = require(&apos;async&apos;);var conn = mysql.createConnection(&#123; host: &apos;localhost&apos;, user: &apos;nodejs&apos;, password: &apos;nodejs&apos;, database: &apos;nodejs&apos;, port: 3306&#125;);var sqls = &#123; &apos;insertSQL&apos;: &apos;insert into t_user(name) values(&quot;conan&quot;),(&quot;fens.me&quot;)&apos;, &apos;selectSQL&apos;: &apos;select * from t_user limit 10&apos;, &apos;deleteSQL&apos;: &apos;delete from t_user&apos;, &apos;updateSQL&apos;: &apos;update t_user set name=&quot;conan update&quot; where name=&quot;conan&quot;&apos;&#125;;var tasks = [&apos;deleteSQL&apos;, &apos;insertSQL&apos;, &apos;selectSQL&apos;, &apos;updateSQL&apos;, &apos;selectSQL&apos;];async.eachSeries(tasks, function (item, callback) &#123; console.log(item + &quot; ==&gt; &quot; + sqls[item]); conn.query(sqls[item], function (err, res) &#123; console.log(res); callback(err, res); &#125;);&#125;, function (err) &#123; console.log(&quot;err: &quot; + err);&#125;); 控制台输出 123456789101112131415161718192021222324252627282930313233343536373839404142deleteSQL ==&gt; delete from t_user&#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 34, warningCount: 0, message: &apos;&apos;, protocol41: true, changedRows: 0 &#125;insertSQL ==&gt; insert into t_user(name) values(&quot;conan&quot;),(&quot;fens.me&quot;)&#123; fieldCount: 0, affectedRows: 2, insertId: 45, serverStatus: 2, warningCount: 0, message: &apos;&amp;Records: 2 Duplicates: 0 Warnings: 0&apos;, protocol41: true, changedRows: 0 &#125;selectSQL ==&gt; select * from t_user limit 10[ &#123; id: 45, name: &apos;conan&apos;, create_date: Fri Sep 13 2013 12:24:51 GMT+0800 (中国标准时间) &#125;, &#123; id: 46, name: &apos;fens.me&apos;, create_date: Fri Sep 13 2013 12:24:51 GMT+0800 (中国标准时间) &#125; ]updateSQL ==&gt; update t_user set name=&quot;conan update&quot; where name=&quot;conan&quot;&#123; fieldCount: 0, affectedRows: 1, insertId: 0, serverStatus: 2, warningCount: 0, message: &apos;(Rows matched: 1 Changed: 1 Warnings: 0&apos;, protocol41: true, changedRows: 1 &#125;selectSQL ==&gt; select * from t_user limit 10[ &#123; id: 45, name: &apos;conan update&apos;, create_date: Fri Sep 13 2013 12:24:51 GMT+0800 (中国标准时间) &#125;, &#123; id: 46, name: &apos;fens.me&apos;, create_date: Fri Sep 13 2013 12:24:51 GMT+0800 (中国标准时间) &#125; ]err: null 代码一下读性就增强了许多倍，这就是高效的开发。 不用不知道，一用真强大！！！当然还有其他的工作流框架来完成这件事情step,then.js,windjs。windjs请参考：wind.js助力异步编程 6. async_demo我的分支demo forEach.js改名为each.js each.js文件中的async.forEach，改为async.each map.js增加mapLimit函数 filter_reject.js对注释补充 filter_reject.js增加rejectSeries函数 reduce.js增加注释 detect.js增加注释 sortBy.js增加注释 some.js对注释补充 every.js对注释补充和修改 series.js调整注释格式 parallel.js调整注释格式 parallel.js增加parallelLimit函数 whilist_until.js调整注释格式 whilist_until.js增加doWhilst函数 whilist_until.js增加doUntil函数 whilist_until.js增加forever函数 waterfall.js调整注释格式 增加compose.js文件 apply.js补充注释并增加一个实例 修改nextTick.js实例 增加times.js文件，包括times和timesSeries函数 修改iterator.js实例 修正auto.js关于第二个实例的错误解释 修改queue.js实例和注释 修改cargo.js文件 增加applyEach.js文件 修改utils.js实例和注释","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"封装分页（包含js/jq/ajax/juice。。。）","slug":"2015-11-18-封装分页[juerce ajaxjq nodejs]","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:12:55.176Z","comments":true,"path":"2015/12/20/2015-11-18-封装分页[juerce ajaxjq nodejs]/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-11-18-封装分页[juerce ajaxjq nodejs]/","excerpt":"","text":"封装分页（包含js/jq/ajax/juice。。。） 模板部分：product-list-tpl.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type=&quot;text/juicer&quot; id=&quot;product-list-tpl&quot;&gt; &#123;@each products as product&#125; &#123;@set statusName = &apos;&apos; &#125; &#123;@set className = &apos;&apos; &#125; &#123;@if product.status ==&apos;销售中&apos; &#125; &#123;@set className = &apos;button-div&apos; &#125; &#123;@set statusName =&quot;立即购买&quot; &#125; &#123;@else if product.status ==&apos;待上架&apos;&#125; &#123;@set className = &apos;button-div button-arive&apos; &#125; &#123;@set statusName =&quot;预售&quot; &#125; &#123;@else if product.status ==&apos;售完&apos;|| products.status ==&apos;兑付中&apos; &#125; &#123;@set className = &apos;button-div-saleout&apos; &#125; &#123;@set statusName =&quot;已售完&quot; &#125; &#123;@else if product.status ==&apos;已兑付&apos; &#125; &#123;@set className = &apos;status-p1&apos; &#125; &#123;@set statusName =&quot;已兑付&quot; &#125; &#123;@/if&#125; &lt;div class=&quot;product-list&quot;&gt; &lt;div class=&quot;pro-list-left pro-list-left-bj1&quot;&gt; &lt;p class=&quot;pro-p1&quot;&gt;$&#123;product.name&#125;&lt;/p&gt; &lt;p class=&quot;p1&quot;&gt;年化收益率&lt;/p&gt; &lt;p class=&quot;pro-p3&quot;&gt;$&#123;(product.rate + product.extraRate)&#125;&lt;span&gt;%&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;pro-list-right&quot;&gt; &lt;div class=&quot;right-top&quot;&gt; &lt;p class=&quot;right-top-p right-p-border&quot;&gt;可购金额（元）&lt;br&gt; &lt;span class=&quot;num&quot;&gt;$&#123;product.remainAmt&#125;&lt;/span&gt; &lt;/p&gt; &lt;p class=&quot;right-top-p&quot;&gt;理财期限（天）&lt;br&gt; &lt;span class=&quot;num&quot;&gt;$&#123;product.duration&#125;&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right-bottom&quot;&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;num-div&quot;&gt; &lt;p class=&quot;num&quot;&gt;起购金额：$&#123;product.limitAmt&#125;元&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;$&#123;className&#125;&quot;&gt; &lt;a href=&quot;/product/detail/$&#123;product.id&#125;&quot;&gt;$&#123;statusName&#125;&lt;/a&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;!--product-list end--&gt; &#123;@/each&#125;&lt;/script&gt; 页面部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/stylesheets/productlist.css&quot;&gt;&lt;!--&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/stylesheets/paging.css&quot; /&gt;--&gt;&lt;div class=&quot;index-banner&quot;&gt; &lt;div class=&quot;hd&quot;&gt; &lt;ul class=&quot;num&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;ul class=&quot;pic&quot;&gt; &lt;!-- 作者：zhongciyisheng@live.com 时间：2015-11-03 描述：动态添加图片，要添加图片和连接，青岛addbannerimges.js文件添加 --&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;pnBtn prev&quot;&gt; &lt;span class=&quot;blackBg&quot;&gt;&lt;/span&gt; &lt;a class=&quot;arrow&quot; href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;pnBtn next&quot;&gt; &lt;span class=&quot;blackBg&quot;&gt;&lt;/span&gt; &lt;a class=&quot;arrow&quot; href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--index-banner end--&gt;&lt;div class=&quot;bank&quot;&gt;&lt;/div&gt;&lt;!--轮播下面的空白--&gt;&lt;div class=&quot;licai&quot;&gt; &lt;div class=&quot;full&quot;&gt; &lt;div class=&quot;licai-p&quot;&gt; &lt;p class=&quot;licai-product&quot;&gt;理财产品&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;!-- 作者：zhongciyisheng@live.com 时间：2015-11-18 描述：装载产品列表区域，为便于后期维护查找。特意做此备注 --&gt; &lt;/div&gt; &lt;div &gt; &lt;ul id=&quot;pagination&quot; class=&quot;pagination-sm&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;!--full end--&gt;&lt;/div&gt;&lt;!--licai end--&gt;&lt;%-partial(&apos;../template/product-list-tpl&apos;) %&gt; &lt;!--&lt;script src=&quot;/js/jquery.pagination.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;--&gt; &lt;!--&lt;script src=&quot;/js/modules/paging-config.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;--&gt; &lt;script src=&quot;/js/modules/productlist-config.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * Created by lrh on 17/11/15. * pagination use jquery twbs-pagination plugin * twbs-pagination defaults param * defaults = &#123; totalPages: 1, startPage: 1, visiblePages: 5, initiateStartPageClick: true, href: false, pageVariable: &apos;&#123;-&#123; pa----ge &#125;-&#125;&apos;, totalPagesVariable: &apos;&#123;&#123;total_pages&#125;&#125;&apos;, page: null, first: &apos;First&apos;, prev: &apos;Previous&apos;, next: &apos;Next&apos;, last: &apos;Last&apos;, loop: false, onPageClick: null, paginationClass: &apos;pagination&apos;, nextClass: &apos;next&apos;, prevClass: &apos;prev&apos;, lastClass: &apos;last&apos;, firstClass: &apos;first&apos;, pageClass: &apos;page&apos;, activeClass: &apos;active&apos;, disabledClass: &apos;disabled&apos; &#125; */define(function(require, exports, module) &#123; require(&apos;/stylesheets/pagination.css&apos;); require(&apos;jpagination&apos;); require(&apos;juicer&apos;); var pagination; var currentPage = 1; var cacheParam; var pPlugin; var defaults = &#123; first:&apos;首页&apos;, prev:&apos;上一页&apos;, next:&apos;下一页&apos;, last:&apos;尾页&apos;, startPage:1, visiblePages: 5, initiateStartPageClick: false, onPageClick: function (event, page) &#123; currentPage = page; pagination.request(cacheParam); &#125; &#125;; /** * * @param content 展示内容的对象 * @param tplId list模板的id * @param url 请求数据的url * @constructor */ function Pagination(content,tplId,url)&#123; this.content = content; this.tplId = tplId; this.url = url; pagination = this; &#125; Pagination.prototype.withErrorCallBack = function(errorCallBack)&#123; this.errorCallBack = errorCallBack; &#125; Pagination.prototype.render = function(data)&#123; this.content.html(juicer(this.tplId,data)); &#125; Pagination.prototype.request = function(param)&#123; if(!cacheParam)&#123; cacheParam = param||&#123;&#125;; &#125; var reqParam = $.extend(&#123;&#125;,cacheParam,&#123;currentPage:currentPage&#125;); $.ajax(&#123; type: &quot;POST&quot;, dataType: &quot;jsonp&quot;, url: pagination.url, data: reqParam, success: function (data) &#123; if(data.err_code == &apos;0&apos;)&#123; if(!pPlugin)&#123; pPlugin = pagination.initPage(&#123;totalPages:Number(data.page.pageNum)&#125;); &#125;else&#123; pPlugin.options.totalPages = Number(data.page.pageNum); &#125; pagination.render(data.data); &#125;else if(pagination.errorCallBack)&#123; pagination.errorCallBack(data); &#125; &#125; &#125;); &#125; /** * chu * @param options * @returns &#123;*|jQuery&#125; */ Pagination.prototype.initPage = function(options)&#123; var dp = $.extend(&#123;&#125;,defaults,options); $(&apos;#pagination&apos;).parent().css(&apos;text-align&apos;,&apos;center&apos;); return new $.fn.twbsPagination(&apos;#pagination&apos;,dp); &#125; module.exports =Pagination;&#125;)","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"git","slug":"2015-10-19-git之配置","date":"2015-12-19T16:00:00.000Z","updated":"2016-01-03T05:26:38.000Z","comments":true,"path":"2015/12/20/2015-10-19-git之配置/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-10-19-git之配置/","excerpt":"一 .设置git的user name和email：[因为git bash 上是自带了$，所以为了方便复制，我这里就不带$了，直接复制过去，改掉””里面的东西就可以用了] 12git config --global user.name &quot;wushuang&quot;git config --global user.email &quot;wushuang@jicai.com&quot; 二 生成密钥 :1ssh-keygen -t rsa -C &quot;wushuang@jicai.com&quot; 按3个回车，密码为空。(不要输密码) 然后到.ssh下面将id_rsa.pub里的内容复制出来粘贴到github个人中心的账户设置的ssh key里面 git for windows下载地址","text":"一 .设置git的user name和email：[因为git bash 上是自带了$，所以为了方便复制，我这里就不带$了，直接复制过去，改掉””里面的东西就可以用了] 12git config --global user.name &quot;wushuang&quot;git config --global user.email &quot;wushuang@jicai.com&quot; 二 生成密钥 :1ssh-keygen -t rsa -C &quot;wushuang@jicai.com&quot; 按3个回车，密码为空。(不要输密码) 然后到.ssh下面将id_rsa.pub里的内容复制出来粘贴到github个人中心的账户设置的ssh key里面 git for windows下载地址","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"npm功能一览","slug":"2015-10-19-npm常用功能一览","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-18T04:11:31.619Z","comments":true,"path":"2015/12/20/2015-10-19-npm常用功能一览/","link":"","permalink":"http://yoursite.com/2015/12/20/2015-10-19-npm常用功能一览/","excerpt":"","text":"npm 常用功能归纳 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;b&gt;模块名&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;作者&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&lt;b&gt;简介&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;async&quot; href=&quot;https://www.npmjs.com/package/async&quot; target=&quot;_blank&quot;&gt;async&lt;/a&gt;&lt;/td&gt;&lt;td&gt;caolan&lt;/td&gt;&lt;td&gt;异步操作管理&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;bl&quot; href=&quot;https://www.npmjs.com/package/bl&quot; target=&quot;_blank&quot;&gt;bl&lt;/a&gt;&lt;/td&gt;&lt;td&gt;rvagg&lt;/td&gt;&lt;td&gt;二进制数据解析&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;bluebird&quot; href=&quot;https://www.npmjs.com/package/bluebird&quot; target=&quot;_blank&quot;&gt;bluebird&lt;/a&gt;&lt;/td&gt;&lt;td&gt;petkaantonov&lt;/td&gt;&lt;td&gt;异步操作管理&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;browserify&quot; href=&quot;https://www.npmjs.com/package/browserify&quot; target=&quot;_blank&quot;&gt;browserify&lt;/a&gt;&lt;/td&gt;&lt;td&gt;substack&lt;/td&gt;&lt;td&gt;发布浏览器可用的包&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;bunyan&quot; href=&quot;https://www.npmjs.com/package/bunyan&quot; target=&quot;_blank&quot;&gt;bunyan&lt;/a&gt;&lt;/td&gt;&lt;td&gt;trentm&lt;/td&gt;&lt;td&gt;日志（logging）管理&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;chai&quot; href=&quot;https://www.npmjs.com/package/chai&quot; target=&quot;_blank&quot;&gt;chai&lt;/a&gt;&lt;/td&gt;&lt;td&gt;jakeluer&lt;/td&gt;&lt;td&gt;断言&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;chalk&quot; href=&quot;https://www.npmjs.com/package/chalk&quot; target=&quot;_blank&quot;&gt;chalk&lt;/a&gt;&lt;/td&gt;&lt;td&gt;sindresorhus&lt;/td&gt;&lt;td&gt;命令行彩色输出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;co&quot; href=&quot;https://www.npmjs.com/package/co&quot; target=&quot;_blank&quot;&gt;co&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tjholowaychuk&lt;/td&gt;&lt;td&gt;异步流程管理&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;colors&quot; href=&quot;https://www.npmjs.com/package/colors&quot; target=&quot;_blank&quot;&gt;colors&lt;/a&gt;&lt;/td&gt;&lt;td&gt;marak&lt;/td&gt;&lt;td&gt;命令行彩色输出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;commander&quot; href=&quot;https://www.npmjs.com/package/commander&quot; target=&quot;_blank&quot;&gt;commander&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tjholowaychuk&lt;/td&gt;&lt;td&gt;命令行工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;debug&quot; href=&quot;https://www.npmjs.com/package/debug&quot; target=&quot;_blank&quot;&gt;debug&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tjholowaychuk&lt;/td&gt;&lt;td&gt;Debug输出器&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;dockerode&quot; href=&quot;https://www.npmjs.com/package/dockerode&quot; target=&quot;_blank&quot;&gt;dockerode&lt;/a&gt;&lt;/td&gt;&lt;td&gt;apocas&lt;/td&gt;&lt;td&gt;Docker管理&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;duplexify&quot; href=&quot;https://www.npmjs.com/package/duplexify&quot; target=&quot;_blank&quot;&gt;duplexify&lt;/a&gt;&lt;/td&gt;&lt;td&gt;mafintosh&lt;/td&gt;&lt;td&gt;Stream流操作工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;event-stream&quot; href=&quot;https://www.npmjs.com/package/event-stream&quot; target=&quot;_blank&quot;&gt;event-stream&lt;/a&gt;&lt;/td&gt;&lt;td&gt;dominictarr&lt;/td&gt;&lt;td&gt;Stream流操作工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;express&quot; href=&quot;https://www.npmjs.com/package/express&quot; target=&quot;_blank&quot;&gt;express&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tjholowaychuk&lt;/td&gt;&lt;td&gt;Server服务器框架&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;glob&quot; href=&quot;https://www.npmjs.com/package/glob&quot; target=&quot;_blank&quot;&gt;glob&lt;/a&gt;&lt;/td&gt;&lt;td&gt;isaacs&lt;/td&gt;&lt;td&gt;文件名匹配&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;grunt&quot; href=&quot;https://www.npmjs.com/package/grunt&quot; target=&quot;_blank&quot;&gt;grunt&lt;/a&gt;&lt;/td&gt;&lt;td&gt;cowboy&lt;/td&gt;&lt;td&gt;构建工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;gulp&quot; href=&quot;https://www.npmjs.com/package/gulp&quot; target=&quot;_blank&quot;&gt;gulp&lt;/a&gt;&lt;/td&gt;&lt;td&gt;contra&lt;/td&gt;&lt;td&gt;构建工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;hapi&quot; href=&quot;https://www.npmjs.com/package/hapi&quot; target=&quot;_blank&quot;&gt;hapi&lt;/a&gt;&lt;/td&gt;&lt;td&gt;hueniverse&lt;/td&gt;&lt;td&gt;Server服务器框架&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;hyperquest&quot; href=&quot;https://www.npmjs.com/package/hyperquest&quot; target=&quot;_blank&quot;&gt;hyperquest&lt;/a&gt;&lt;/td&gt;&lt;td&gt;substack&lt;/td&gt;&lt;td&gt;轻量级HTTP客户端&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;istanbul&quot; href=&quot;https://www.npmjs.com/package/istanbul&quot; target=&quot;_blank&quot;&gt;istanbul&lt;/a&gt;&lt;/td&gt;&lt;td&gt;gotwarlost&lt;/td&gt;&lt;td&gt;测试用例覆盖率分析&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;JSONStream&quot; href=&quot;https://www.npmjs.com/package/JSONStream&quot; target=&quot;_blank&quot;&gt;JSONStream&lt;/a&gt;&lt;/td&gt;&lt;td&gt;dominictarr&lt;/td&gt;&lt;td&gt;Stream流管理工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;koa&quot; href=&quot;https://www.npmjs.com/package/koa&quot; target=&quot;_blank&quot;&gt;koa&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tjholowaychuk&lt;/td&gt;&lt;td&gt;Server服务器框架&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;levelup&quot; href=&quot;https://www.npmjs.com/package/levelup&quot; target=&quot;_blank&quot;&gt;levelup&lt;/a&gt;&lt;/td&gt;&lt;td&gt;rvagg&lt;/td&gt;&lt;td&gt;LevelDB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;lodash&quot; href=&quot;https://www.npmjs.com/package/lodash&quot; target=&quot;_blank&quot;&gt;lodash&lt;/a&gt;&lt;/td&gt;&lt;td&gt;jdalton&lt;/td&gt;&lt;td&gt;函数式编程工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;log4js&quot; href=&quot;https://www.npmjs.com/package/log4js&quot; target=&quot;_blank&quot;&gt;log4js&lt;/a&gt;&lt;/td&gt;&lt;td&gt;nomiddlename&lt;/td&gt;&lt;td&gt;日志（logging）管理工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;minimatch&quot; href=&quot;https://www.npmjs.com/package/minimatch&quot; target=&quot;_blank&quot;&gt;minimatch&lt;/a&gt;&lt;/td&gt;&lt;td&gt;isaacs&lt;/td&gt;&lt;td&gt;文件名匹配&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;minimist&quot; href=&quot;https://www.npmjs.com/package/minimist&quot; target=&quot;_blank&quot;&gt;minimist&lt;/a&gt;&lt;/td&gt;&lt;td&gt;substack&lt;/td&gt;&lt;td&gt;命令行操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;mocha&quot; href=&quot;https://www.npmjs.com/package/mocha&quot; target=&quot;_blank&quot;&gt;mocha&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tjholowaychuk&lt;/td&gt;&lt;td&gt;单元测试&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;moment&quot; href=&quot;https://www.npmjs.com/package/moment&quot; target=&quot;_blank&quot;&gt;moment&lt;/a&gt;&lt;/td&gt;&lt;td&gt;timrwood&lt;/td&gt;&lt;td&gt;日期时间输出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;mongodb&quot; href=&quot;https://www.npmjs.com/package/mongodb&quot; target=&quot;_blank&quot;&gt;mongodb&lt;/a&gt;&lt;/td&gt;&lt;td&gt;christkv&lt;/td&gt;&lt;td&gt;MongoDB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;mysql&quot; href=&quot;https://www.npmjs.com/package/mysql&quot; target=&quot;_blank&quot;&gt;mysql&lt;/a&gt;&lt;/td&gt;&lt;td&gt;felixge&lt;/td&gt;&lt;td&gt;MySQL&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;nconf&quot; href=&quot;https://www.npmjs.com/package/nconf&quot; target=&quot;_blank&quot;&gt;nconf&lt;/a&gt;&lt;/td&gt;&lt;td&gt;indexzero&lt;/td&gt;&lt;td&gt;配置工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;needle&quot; href=&quot;https://www.npmjs.com/package/needle&quot; target=&quot;_blank&quot;&gt;needle&lt;/a&gt;&lt;/td&gt;&lt;td&gt;tomas&lt;/td&gt;&lt;td&gt;轻量级HTTP客户端&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;node-fetch&quot; href=&quot;https://www.npmjs.com/package/node-fetch&quot; target=&quot;_blank&quot;&gt;node-fetch&lt;/a&gt;&lt;/td&gt;&lt;td&gt;bitinn&lt;/td&gt;&lt;td&gt;Fetch API&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;nodemailer&quot; href=&quot;https://www.npmjs.com/package/nodemailer&quot; target=&quot;_blank&quot;&gt;nodemailer&lt;/a&gt;&lt;/td&gt;&lt;td&gt;andris9&lt;/td&gt;&lt;td&gt;Email客户端&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;passport&quot; href=&quot;https://www.npmjs.com/package/passport&quot; target=&quot;_blank&quot;&gt;passport&lt;/a&gt;&lt;/td&gt;&lt;td&gt;jaredhanson&lt;/td&gt;&lt;td&gt;登录和认证&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;pg&quot; href=&quot;https://www.npmjs.com/package/pg&quot; target=&quot;_blank&quot;&gt;pg&lt;/a&gt;&lt;/td&gt;&lt;td&gt;brianc&lt;/td&gt;&lt;td&gt;Postgres&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;pump&quot; href=&quot;https://www.npmjs.com/package/pump&quot; target=&quot;_blank&quot;&gt;pump&lt;/a&gt;&lt;/td&gt;&lt;td&gt;mafintosh&lt;/td&gt;&lt;td&gt;Stream流管理工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;redis&quot; href=&quot;https://www.npmjs.com/package/redis&quot; target=&quot;_blank&quot;&gt;redis&lt;/a&gt;&lt;/td&gt;&lt;td&gt;mjr&lt;/td&gt;&lt;td&gt;Redis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;request&quot; href=&quot;https://www.npmjs.com/package/request&quot; target=&quot;_blank&quot;&gt;request&lt;/a&gt;&lt;/td&gt;&lt;td&gt;mikeal&lt;/td&gt;&lt;td&gt;HTTP客户端&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;restify&quot; href=&quot;https://www.npmjs.com/package/restify&quot; target=&quot;_blank&quot;&gt;restify&lt;/a&gt;&lt;/td&gt;&lt;td&gt;mcavage&lt;/td&gt;&lt;td&gt;REST API搭建&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;socket.io&quot; href=&quot;https://www.npmjs.com/package/socket.io&quot; target=&quot;_blank&quot;&gt;socket.io&lt;/a&gt;&lt;/td&gt;&lt;td&gt;rauchg&lt;/td&gt;&lt;td&gt;WebSocket实时通信&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;split2&quot; href=&quot;https://www.npmjs.com/package/split2&quot; target=&quot;_blank&quot;&gt;split2&lt;/a&gt;&lt;/td&gt;&lt;td&gt;matteo.collina&lt;/td&gt;&lt;td&gt;Stream流管理工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;tape&quot; href=&quot;https://www.npmjs.com/package/tape&quot; target=&quot;_blank&quot;&gt;tape&lt;/a&gt;&lt;/td&gt;&lt;td&gt;substack&lt;/td&gt;&lt;td&gt;单元测试&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;through2&quot; href=&quot;https://www.npmjs.com/package/through2&quot; target=&quot;_blank&quot;&gt;through2&lt;/a&gt;&lt;/td&gt;&lt;td&gt;rvagg&lt;/td&gt;&lt;td&gt;Stream流管理工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;underscore&quot; href=&quot;https://www.npmjs.com/package/underscore&quot; target=&quot;_blank&quot;&gt;underscore&lt;/a&gt;&lt;/td&gt;&lt;td&gt;jashkenas&lt;/td&gt;&lt;td&gt;函数式编程工具&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;ws&quot; href=&quot;https://www.npmjs.com/package/ws&quot; target=&quot;_blank&quot;&gt;ws&lt;/a&gt;&lt;/td&gt;&lt;td&gt;einaros&lt;/td&gt;&lt;td&gt;Websockets&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a title=&quot;xml2js&quot; href=&quot;https://www.npmjs.com/package/xml2js&quot; target=&quot;_blank&quot;&gt;xml2js&lt;/a&gt;&lt;/td&gt;&lt;td&gt;leonidas&lt;/td&gt;&lt;td&gt;XML转换为JavaScript&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}]},{"title":"快速排序（Quicksort）的Javascript实现","slug":"快速排序（Quicksort）的Javascript实现","date":"2015-07-15T12:46:25.000Z","updated":"2017-06-18T03:51:56.272Z","comments":true,"path":"2015/07/15/快速排序（Quicksort）的Javascript实现/","link":"","permalink":"http://yoursite.com/2015/07/15/快速排序（Quicksort）的Javascript实现/","excerpt":"","text":"日本程序员norahiko，写了一个排序算法的动画演示，非常有趣。 排序算法（Sorting algorithm）是计算机科学最古老、最基本的课题之一。要想成为合格的程序员，就必须理解和掌握各种排序算法。目前，最常见的排序算法大概有七八种，其中“快速排序”（Quicksort）使用得最广泛，速度也较快。它是图灵奖得主C. A. R. Hoare（1934–）于1960时提出来的。 排序算法（Sorting algorithm）是计算机科学最古老、最基本的课题之一。要想成为合格的程序员，就必须理解和掌握各种排序算法。 目前，最常见的排序算法大概有七八种，其中“快速排序”（Quicksort）使用得最广泛，速度也较快。它是图灵奖得主C. A. R. Hoare（1934–）于1960时提出来的。 “快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 举例来说，现在有一个数据集{85, 24, 63, 45, 17, 31, 96, 50}，怎么对其排序呢？第一步，选择中间的元素45作为”基准”。（基准值可以任意选择，但是选择中间的值比较容易理解。） 第二步，按照顺序，将每个元素与”基准”进行比较，形成两个子集，一个”小于45”，另一个”大于等于45”。 第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 下面参照网上的资料（这里和这里），用Javascript语言实现上面的算法。首先，定义一个quickSort函数，它的参数是一个数组。12var quickSort = function(arr) &#123;&#125;; 然后，检查数组的元素个数，如果小于等于1，就返回。123var quickSort = function(arr) &#123; **if (arr.length &lt;= 1) &#123; return arr; &#125;**&#125;; 接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。1234567var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; **var pivotIndex = Math.floor(arr.length / 2) ;** **var pivot = arr.splice(pivotIndex, 1)[0];** **var left = [];** **var right = [];**&#125;; 然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。1234567891011121314var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2) ; var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; **for (var i = 0; i &lt; arr.length; i++)&#123;** **if (arr[i] &lt; pivot) &#123;** **left.push(arr[i]);** **&#125; else &#123;** **right.push(arr[i]);** **&#125;** **&#125;**&#125;; 最后，使用递归不断重复这个过程，就可以得到排序后的数组。123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; **return quickSort(left).concat([pivot], quickSort(right));**&#125;; 使用的时候，直接调用quickSort()就行了。 (END摘自)","categories":[],"tags":[],"keywords":[]},{"title":"10个常见的Node-js面试题","slug":"10个常见的Node-js面试题","date":"2015-07-13T12:46:25.000Z","updated":"2017-06-18T02:57:58.599Z","comments":true,"path":"2015/07/13/10个常见的Node-js面试题/","link":"","permalink":"http://yoursite.com/2015/07/13/10个常见的Node-js面试题/","excerpt":"","text":"这篇文章来自 Github 上的一位开发者收集整理的 Node.js 中文学习资料和教程导航。Node 是一个服务器端 JavaScript 解释器，它将改变服务器应该如何工作的概念，它的目标是帮助程序员构建高度可伸缩的应用程序。这些参考资料和教程能够帮助你更好的掌握 Node.js 的应用。 如果你希望找一份有关Node.js的工作，但又不知道从哪里入手评测自己对Node.js的掌握程度。 本文就为你罗列了10个常见的Node.js面试题，分别考察了Node.js编程相关的几个主要方面。在进入正文之前，需要提前声明两点： 这些问题只是Node.js知识体系的一个局部，并不能完全考察被面试者的实际开发能力。 对现实世界开发中遇到的问题，需要的是随机应变与团队合作，所以你可以尝试结对编程。 Node.js面试题列表 什么是错误优先的回调函数？ 如何避免回调地狱？ 如何用Node来监听80端口？ 什么是事件循环？ 哪些工具可以用来保证一致的编程风格？ 运算错误与程序员错误的区别？ 使用NPM有哪些好处？ 什么是stub？举个使用场景？ 什么是测试金字塔？对于HTTP API，如何利用测试金字塔？ 你最喜欢的HTTP框架，并说明原因？ 现在，我们依次来解答这些问题吧。 什么是错误优先的回调函数？错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。例如：123456fs.readFile(filePath, function(err, data) &#123; if (err) &#123; //handle the error &#125; // use the data object&#125;); 解析：这个题目的主要作用在于检查被面试者对于Node中异步操作的一些基本知识的掌握。 如何避免回调地狱你可以有如下几个方法： 模块化：将回调函数分割为独立的函数 使用Promises 使用yield来计算生成器或Promise 解析：这个问题有很多种答案，取决你使用的场景，例如ES6, ES7，或者一些控制流库。 如何用Node监听80端口这题有陷阱！在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。 目前，如果你一定要让你的应用监听80端口的话，你可以有通过在Node应用的前方再增加一层反向代理 （例如nginx）来实现，如下图所示。否则，建议你直接监听大于1024的端口。 方向代理指的是以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。 关于反向代理的更多内容，建议你阅读这篇文章。 解释：这个问题用于检查被面试者是否有实际运行Node应用的经验。 什么是事件循环Node采用的是单线程的处理机制（所有的I/O请求都采用非阻塞的工作方式），至少从Node.js开发者的角度是这样的。 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。下图表示了Node和libuv的关系。 Libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个事件循环， 以异步的方式将任务的执行结果返回给V8引擎。可以简单用下面这张图来表示。 每一个I/O都需要一个回调函数——一旦执行完便推到事件循环上用于执行。 如果你需要更多详细的解释，可以参考这个视频。 你也可以参考这篇文章。 解释：这用于检查Node.js的底层知识，例如什么是libuv，它的作用是什么 哪些工具可以用来保证一致性的代码风格你可以选择如下的工具： JSLint JSHint ESLint JSCS - 推荐 在团队开发中，这些工具对于编写代码非常的有帮助，能够帮助团队开发者强制执行规定的风格指南， 还能够通过静态分析捕获常见的错误。 解析：用于检查被面试者是否有大型项目开发经验。 运算错误与程序员错误的区别运算错误并不是bug，这是和系统相关的问题，例如请求超时或者硬件故障。而程序员错误就是所谓的bug。 解析：这个题目和Node关系并不大，用于考察面试者的基础知识。 使用NPM有哪些好处？ 通过NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。 对于Node应用开发而言，你可以通过package.json文件来管理项目信息，配置脚本， 以及指明项目依赖的具体版本。 关于NPM的更多信息，你可以参考官方文档。 解析：它能考察面试者使用npm命令的基础知识和Node.js开发的实际经验。 什么是Stub？举个使用场景 Stub是用于模拟一个组件或模块的函数或程序。在测试用例中， 简单的说，你可以用Stub去模拟一个方法，从而避免调用真实的方法， 使用Stub你还可以返回虚构的结果。你可以配合断言使用Stub。 举个例子，在一个读取文件的场景中，当你不想读取一个真正的文件时： 12345678var fs = require(&apos;fs&apos;);var readFileStub = sinon.stub(fs, &apos;readFile&apos;, function (path, cb) &#123; return cb(null, &apos;filecontent&apos;);&#125;);expect(readFileStub).to.be.called; readFileStub.restore(); 在单元测试中：Stub是完全模拟一个外部依赖，而Mock常用来判断测试通过还是失败。 有关Node.js的单元测试小结，你可以参考这个链接。 解析：用于测试被面试者是否有测试的经验。如果被面试者知道什么是Stub， 那么可以继续问他是如何做单元测试的。 什么是测试金字塔？测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。 当我们谈到HTTP API时，我们可能会涉及到： 有很多针对模型的底层单元测试 但你需要测试模型间如何交互时，需要减少集成测试 解析：本文主要考察被面试者的在测试方面的经验。 你最喜欢的HTTP框架以及原因这题没有唯一的答案。本题主要考察被面试者对于他所使用的Node框架的理解程度， 考察他是否能够给出选择该框架的理由，优缺点等。常用的HTTP框架你可以参考这个网站。 Statement 原文地址：https://blog.risingstack.com/node-js-interview-questions References [http://zyzhang.github.io/blog/2013/04/28/test-pyramid/]- (http://zyzhang.github.io/blog/2013/04/28/test-pyramid/) http://www.ruanyifeng.com/blog/2014/10/event-loop.html http://segmentfault.com/a/1190000002921481 摘自","categories":[],"tags":[],"keywords":[]}]}